/* tslint:disable */
/* eslint-disable */
/**
 * Clinic Management API
 * API documentation for the Clinic Management system
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface AccountSettingResponse {
    'username'?: string;
    'email'?: string;
    'active'?: boolean;
    'mfaEnabled'?: boolean;
    'firstLogin'?: boolean;
    'OAuthAccounts'?: Set<OAuthAccountResponse>;
}
export interface AddressResponse {
    'street'?: string;
    'wardName'?: string;
    'districtName'?: string;
    'city'?: string;
}
export interface AdministrativeUnitResponse {
    'code'?: string;
    'name'?: string;
}
export interface AllergyRequest {
    'substance': string;
    'reaction': string;
    'severity': string;
}
export interface AllergyResponse {
    'id'?: string;
    'substance'?: string;
    'reaction'?: string;
    'severity'?: string;
}
export interface AppId {
    'id'?: string;
}
export interface AppointmentRequest {
    'patientId'?: string;
    'specialtyId'?: string;
    'type'?: AppointmentRequestTypeEnum;
    'status'?: AppointmentRequestStatusEnum;
    'source'?: AppointmentRequestSourceEnum;
    'note'?: string;
}

export const AppointmentRequestTypeEnum = {
    Consultation: 'CONSULTATION',
    FollowUp: 'FOLLOW_UP',
    Emergency: 'EMERGENCY',
    Online: 'ONLINE'
} as const;

export type AppointmentRequestTypeEnum = typeof AppointmentRequestTypeEnum[keyof typeof AppointmentRequestTypeEnum];
export const AppointmentRequestStatusEnum = {
    Pending: 'PENDING',
    Confirmed: 'CONFIRMED',
    CheckedIn: 'CHECKED_IN',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED',
    NoShow: 'NO_SHOW'
} as const;

export type AppointmentRequestStatusEnum = typeof AppointmentRequestStatusEnum[keyof typeof AppointmentRequestStatusEnum];
export const AppointmentRequestSourceEnum = {
    System: 'SYSTEM',
    StaffCreated: 'STAFF_CREATED',
    PatientPortal: 'PATIENT_PORTAL',
    MobileApp: 'MOBILE_APP',
    WalkIn: 'WALK_IN'
} as const;

export type AppointmentRequestSourceEnum = typeof AppointmentRequestSourceEnum[keyof typeof AppointmentRequestSourceEnum];

export interface AppointmentResponse {
    'id'?: string;
    'patient'?: PatientResponse;
    'specialty'?: SpecialtyResponse;
    'type'?: AppointmentResponseTypeEnum;
    'status'?: AppointmentResponseStatusEnum;
    'source'?: AppointmentResponseSourceEnum;
    'note'?: string;
    'queueTicket'?: QueueTicketResponse;
    'createdDate'?: string;
}

export const AppointmentResponseTypeEnum = {
    Consultation: 'CONSULTATION',
    FollowUp: 'FOLLOW_UP',
    Emergency: 'EMERGENCY',
    Online: 'ONLINE'
} as const;

export type AppointmentResponseTypeEnum = typeof AppointmentResponseTypeEnum[keyof typeof AppointmentResponseTypeEnum];
export const AppointmentResponseStatusEnum = {
    Pending: 'PENDING',
    Confirmed: 'CONFIRMED',
    CheckedIn: 'CHECKED_IN',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED',
    NoShow: 'NO_SHOW'
} as const;

export type AppointmentResponseStatusEnum = typeof AppointmentResponseStatusEnum[keyof typeof AppointmentResponseStatusEnum];
export const AppointmentResponseSourceEnum = {
    System: 'SYSTEM',
    StaffCreated: 'STAFF_CREATED',
    PatientPortal: 'PATIENT_PORTAL',
    MobileApp: 'MOBILE_APP',
    WalkIn: 'WALK_IN'
} as const;

export type AppointmentResponseSourceEnum = typeof AppointmentResponseSourceEnum[keyof typeof AppointmentResponseSourceEnum];

export interface AssertionExtensionInputs {
    'appid'?: AppId;
    'largeBlob'?: LargeBlobAuthenticationInput;
    'prf'?: PrfAuthenticationInput;
    'uvm'?: boolean;
}
export interface AuthResponse {
    'requires2FA'?: boolean;
    'mfaTypes'?: Array<AuthResponseMfaTypesEnum>;
    'defaultMfaType'?: AuthResponseDefaultMfaTypeEnum;
    'challengeId'?: string;
    'tokenType'?: string;
    'accessToken'?: string;
    'expiresIn'?: string;
    'trustDevice'?: boolean;
    'rememberMe'?: boolean;
    'deviceId'?: string;
}

export const AuthResponseMfaTypesEnum = {
    Totp: 'TOTP',
    Sms: 'SMS',
    Email: 'EMAIL',
    PushNotification: 'PUSH_NOTIFICATION',
    Passkey: 'PASSKEY',
    EmailVerification: 'EMAIL_VERIFICATION'
} as const;

export type AuthResponseMfaTypesEnum = typeof AuthResponseMfaTypesEnum[keyof typeof AuthResponseMfaTypesEnum];
export const AuthResponseDefaultMfaTypeEnum = {
    Totp: 'TOTP',
    Sms: 'SMS',
    Email: 'EMAIL',
    PushNotification: 'PUSH_NOTIFICATION',
    Passkey: 'PASSKEY',
    EmailVerification: 'EMAIL_VERIFICATION'
} as const;

export type AuthResponseDefaultMfaTypeEnum = typeof AuthResponseDefaultMfaTypeEnum[keyof typeof AuthResponseDefaultMfaTypeEnum];

export interface AuthenticatorSelectionCriteria {
    'authenticatorAttachment'?: AuthenticatorSelectionCriteriaAuthenticatorAttachmentEnum;
    'requireResidentKey'?: boolean;
    'residentKey'?: AuthenticatorSelectionCriteriaResidentKeyEnum;
    'userVerification'?: AuthenticatorSelectionCriteriaUserVerificationEnum;
}

export const AuthenticatorSelectionCriteriaAuthenticatorAttachmentEnum = {
    CrossPlatform: 'cross-platform',
    Platform: 'platform'
} as const;

export type AuthenticatorSelectionCriteriaAuthenticatorAttachmentEnum = typeof AuthenticatorSelectionCriteriaAuthenticatorAttachmentEnum[keyof typeof AuthenticatorSelectionCriteriaAuthenticatorAttachmentEnum];
export const AuthenticatorSelectionCriteriaResidentKeyEnum = {
    Discouraged: 'discouraged',
    Preferred: 'preferred',
    Required: 'required'
} as const;

export type AuthenticatorSelectionCriteriaResidentKeyEnum = typeof AuthenticatorSelectionCriteriaResidentKeyEnum[keyof typeof AuthenticatorSelectionCriteriaResidentKeyEnum];
export const AuthenticatorSelectionCriteriaUserVerificationEnum = {
    Discouraged: 'discouraged',
    Preferred: 'preferred',
    Required: 'required'
} as const;

export type AuthenticatorSelectionCriteriaUserVerificationEnum = typeof AuthenticatorSelectionCriteriaUserVerificationEnum[keyof typeof AuthenticatorSelectionCriteriaUserVerificationEnum];

export interface ChangePasswordRequest {
    'currentPassword': string;
    'newPassword': string;
}
export interface ClinicRequest {
    'name': string;
    'description'?: string;
    'phone': string;
    'address'?: AddressResponse;
    'email'?: string;
    'taxCode'?: string;
    'website'?: string;
    'accountNumber'?: string;
    'bankName'?: string;
}
export interface ClinicResponse {
    'id'?: string;
    'name'?: string;
    'description'?: string;
    'phone'?: string;
    'email'?: string;
    'address'?: AddressResponse;
    'departments'?: Array<DepartmentSimpleResponse>;
    'taxCode'?: string;
    'website'?: string;
    'accountNumber'?: string;
    'bankName'?: string;
}
export interface ClinicSimpleResponse {
    'id'?: string;
    'name'?: string;
    'taxCode'?: string;
    'website'?: string;
    'accountNumber'?: string;
    'bankName'?: string;
}
export interface ContentRequest {
    'title'?: string;
    'slug'?: string;
    'body'?: string;
    'excerpt'?: string;
    'coverImageUrl'?: string;
    'status'?: ContentRequestStatusEnum;
    'tags'?: Set<string>;
}

export const ContentRequestStatusEnum = {
    Draft: 'DRAFT',
    Published: 'PUBLISHED',
    Archived: 'ARCHIVED'
} as const;

export type ContentRequestStatusEnum = typeof ContentRequestStatusEnum[keyof typeof ContentRequestStatusEnum];

export interface ContentResponse {
    'id'?: string;
    'createdBy'?: string;
    'createdDate'?: string;
    'lastModifiedBy'?: string;
    'lastModifiedDate'?: string;
    'title'?: string;
    'slug'?: string;
    'body'?: string;
    'excerpt'?: string;
    'coverImageUrl'?: string;
    'status'?: ContentResponseStatusEnum;
    'publishedAt'?: string;
    'tags'?: Set<string>;
    'author'?: StaffResponse;
}

export const ContentResponseStatusEnum = {
    Draft: 'DRAFT',
    Published: 'PUBLISHED',
    Archived: 'ARCHIVED'
} as const;

export type ContentResponseStatusEnum = typeof ContentResponseStatusEnum[keyof typeof ContentResponseStatusEnum];

export interface CreateLabOrderRequest {
    'labTestIds'?: Array<string>;
}
export interface CreateServiceOrderRequest {
    'serviceIds'?: Array<string>;
}
export interface CustomApiResponseAccountSettingResponse {
    'code'?: number;
    'message'?: string;
    'data'?: AccountSettingResponse;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseAllergyResponse {
    'code'?: number;
    'message'?: string;
    'data'?: AllergyResponse;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseAppointmentResponse {
    'code'?: number;
    'message'?: string;
    'data'?: AppointmentResponse;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseAuthResponse {
    'code'?: number;
    'message'?: string;
    'data'?: AuthResponse;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseBoolean {
    'code'?: number;
    'message'?: string;
    'data'?: boolean;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseClinicResponse {
    'code'?: number;
    'message'?: string;
    'data'?: ClinicResponse;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseContentResponse {
    'code'?: number;
    'message'?: string;
    'data'?: ContentResponse;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseDepartmentResponse {
    'code'?: number;
    'message'?: string;
    'data'?: DepartmentResponse;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseDiagnosisResponse {
    'code'?: number;
    'message'?: string;
    'data'?: DiagnosisResponse;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseDispenseRecordResponse {
    'code'?: number;
    'message'?: string;
    'data'?: DispenseRecordResponse;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseEmergencyContactResponse {
    'code'?: number;
    'message'?: string;
    'data'?: EmergencyContactResponse;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseExaminationResponse {
    'code'?: number;
    'message'?: string;
    'data'?: ExaminationResponse;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseIcdCodeResponse {
    'code'?: number;
    'message'?: string;
    'data'?: IcdCodeResponse;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseInvoiceResponse {
    'code'?: number;
    'message'?: string;
    'data'?: InvoiceResponse;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseLabOrderResponse {
    'code'?: number;
    'message'?: string;
    'data'?: LabOrderResponse;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseLabTestResponse {
    'code'?: number;
    'message'?: string;
    'data'?: LabTestResponse;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseLabTestResultResponse {
    'code'?: number;
    'message'?: string;
    'data'?: LabTestResultResponse;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseListAdministrativeUnitResponse {
    'code'?: number;
    'message'?: string;
    'data'?: Array<AdministrativeUnitResponse>;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseListDeviceSessionResponse {
    'code'?: number;
    'message'?: string;
    'data'?: Array<DeviceSessionResponse>;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseListDispenseRecordResponse {
    'code'?: number;
    'message'?: string;
    'data'?: Array<DispenseRecordResponse>;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseListFileAttachmentResponse {
    'code'?: number;
    'message'?: string;
    'data'?: Array<FileAttachmentResponse>;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseListInvoiceResponse {
    'code'?: number;
    'message'?: string;
    'data'?: Array<InvoiceResponse>;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseListLabOrderResponse {
    'code'?: number;
    'message'?: string;
    'data'?: Array<LabOrderResponse>;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseListMfaConfigResponse {
    'code'?: number;
    'message'?: string;
    'data'?: Array<MfaConfigResponse>;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseListPatientByDayResponse {
    'code'?: number;
    'message'?: string;
    'data'?: Array<PatientByDayResponse>;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseListPatientByHourResponse {
    'code'?: number;
    'message'?: string;
    'data'?: Array<PatientByHourResponse>;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseListQueueTicketResponse {
    'code'?: number;
    'message'?: string;
    'data'?: Array<QueueTicketResponse>;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseListRevenueDailyResponse {
    'code'?: number;
    'message'?: string;
    'data'?: Array<RevenueDailyResponse>;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseListServiceOrderResponse {
    'code'?: number;
    'message'?: string;
    'data'?: Array<ServiceOrderResponse>;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseListServiceUsageResponse {
    'code'?: number;
    'message'?: string;
    'data'?: Array<ServiceUsageResponse>;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseListSpecialtyDistributionResponse {
    'code'?: number;
    'message'?: string;
    'data'?: Array<SpecialtyDistributionResponse>;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseListStaffScheduleResponse {
    'code'?: number;
    'message'?: string;
    'data'?: Array<StaffScheduleResponse>;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseListStaffWorkloadResponse {
    'code'?: number;
    'message'?: string;
    'data'?: Array<StaffWorkloadResponse>;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseListString {
    'code'?: number;
    'message'?: string;
    'data'?: Array<string>;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseMapStringLong {
    'code'?: number;
    'message'?: string;
    'data'?: { [key: string]: number; };
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseMeResponse {
    'code'?: number;
    'message'?: string;
    'data'?: MeResponse;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseMedicineResponse {
    'code'?: number;
    'message'?: string;
    'data'?: MedicineResponse;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseMfaConfigResponse {
    'code'?: number;
    'message'?: string;
    'data'?: MfaConfigResponse;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseMfaInitResponse {
    'code'?: number;
    'message'?: string;
    'data'?: MfaInitResponse;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseMfaSetupResponse {
    'code'?: number;
    'message'?: string;
    'data'?: MfaSetupResponse;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseObject {
    'code'?: number;
    'message'?: string;
    'data'?: object;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponsePageAllergyResponse {
    'code'?: number;
    'message'?: string;
    'data'?: PageObject;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponsePageAppointmentResponse {
    'code'?: number;
    'message'?: string;
    'data'?: PageObject;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponsePageClinicResponse {
    'code'?: number;
    'message'?: string;
    'data'?: PageObject;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponsePageContentResponse {
    'code'?: number;
    'message'?: string;
    'data'?: PageObject;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponsePageDepartmentResponse {
    'code'?: number;
    'message'?: string;
    'data'?: PageObject;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponsePageDiagnosisResponse {
    'code'?: number;
    'message'?: string;
    'data'?: PageObject;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponsePageDispenseRecordResponse {
    'code'?: number;
    'message'?: string;
    'data'?: PageObject;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponsePageEmergencyContactResponse {
    'code'?: number;
    'message'?: string;
    'data'?: PageObject;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponsePageExaminationResponse {
    'code'?: number;
    'message'?: string;
    'data'?: PageObject;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponsePageIcdCodeResponse {
    'code'?: number;
    'message'?: string;
    'data'?: PageObject;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponsePageInvoiceResponse {
    'code'?: number;
    'message'?: string;
    'data'?: PageObject;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponsePageLabOrderResponse {
    'code'?: number;
    'message'?: string;
    'data'?: PageObject;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponsePageLabTestResponse {
    'code'?: number;
    'message'?: string;
    'data'?: PageObject;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponsePageLabTestResultResponse {
    'code'?: number;
    'message'?: string;
    'data'?: PageObject;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponsePageLoginAttemptResponse {
    'code'?: number;
    'message'?: string;
    'data'?: PageObject;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponsePageMedicineResponse {
    'code'?: number;
    'message'?: string;
    'data'?: PageObject;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponsePagePatientResponse {
    'code'?: number;
    'message'?: string;
    'data'?: PageObject;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponsePagePositionResponse {
    'code'?: number;
    'message'?: string;
    'data'?: PageObject;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponsePagePrescriptionItemResponse {
    'code'?: number;
    'message'?: string;
    'data'?: PageObject;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponsePageRoomResponse {
    'code'?: number;
    'message'?: string;
    'data'?: PageObject;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponsePageServiceCatalogResponse {
    'code'?: number;
    'message'?: string;
    'data'?: PageObject;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponsePageServiceOrderResponse {
    'code'?: number;
    'message'?: string;
    'data'?: PageObject;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponsePageSpecialtyResponse {
    'code'?: number;
    'message'?: string;
    'data'?: PageObject;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponsePageStaffResponse {
    'code'?: number;
    'message'?: string;
    'data'?: PageObject;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponsePageStaffScheduleResponse {
    'code'?: number;
    'message'?: string;
    'data'?: PageObject;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponsePageStaffScheduleTemplateResponse {
    'code'?: number;
    'message'?: string;
    'data'?: PageObject;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponsePageUserResponse {
    'code'?: number;
    'message'?: string;
    'data'?: PageObject;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponsePageVitalSignResponse {
    'code'?: number;
    'message'?: string;
    'data'?: PageObject;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponsePatientResponse {
    'code'?: number;
    'message'?: string;
    'data'?: PatientResponse;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponsePositionResponse {
    'code'?: number;
    'message'?: string;
    'data'?: PositionResponse;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponsePrescriptionItemResponse {
    'code'?: number;
    'message'?: string;
    'data'?: PrescriptionItemResponse;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponsePrescriptionResponse {
    'code'?: number;
    'message'?: string;
    'data'?: PrescriptionResponse;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponsePublicKeyCredentialCreationOptions {
    'code'?: number;
    'message'?: string;
    'data'?: PublicKeyCredentialCreationOptions;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseQueueTicketResponse {
    'code'?: number;
    'message'?: string;
    'data'?: QueueTicketResponse;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseRoomResponse {
    'code'?: number;
    'message'?: string;
    'data'?: RoomResponse;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseServiceCatalogResponse {
    'code'?: number;
    'message'?: string;
    'data'?: ServiceCatalogResponse;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseServiceOrderResponse {
    'code'?: number;
    'message'?: string;
    'data'?: ServiceOrderResponse;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseSpecialtyResponse {
    'code'?: number;
    'message'?: string;
    'data'?: SpecialtyResponse;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseStaffResponse {
    'code'?: number;
    'message'?: string;
    'data'?: StaffResponse;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseStaffScheduleResponse {
    'code'?: number;
    'message'?: string;
    'data'?: StaffScheduleResponse;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseStaffScheduleTemplateResponse {
    'code'?: number;
    'message'?: string;
    'data'?: StaffScheduleTemplateResponse;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseStartPasskeyLoginResponse {
    'code'?: number;
    'message'?: string;
    'data'?: StartPasskeyLoginResponse;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseString {
    'code'?: number;
    'message'?: string;
    'data'?: string;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseTodaySummaryResponse {
    'code'?: number;
    'message'?: string;
    'data'?: TodaySummaryResponse;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseUserProfileResponse {
    'code'?: number;
    'message'?: string;
    'data'?: UserProfileResponse;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseVitalSignResponse {
    'code'?: number;
    'message'?: string;
    'data'?: VitalSignResponse;
    'timestamp'?: string;
    'path'?: string;
}
export interface CustomApiResponseVoid {
    'code'?: number;
    'message'?: string;
    'data'?: object;
    'timestamp'?: string;
    'path'?: string;
}
export interface DepartmentRequest {
    'name': string;
    'description'?: string;
    'clinicId': string;
}
export interface DepartmentResponse {
    'id'?: string;
    'name'?: string;
    'description'?: string;
    'clinic'?: ClinicSimpleResponse;
    'rooms'?: Array<RoomResponse>;
}
export interface DepartmentSimpleResponse {
    'id'?: string;
    'name'?: string;
    'description'?: string;
}
export interface DeviceInfo {
    'deviceId'?: string;
    'trusted'?: boolean;
    'lastLoginAt'?: string;
}
export interface DeviceSessionResponse {
    'id'?: string;
    'createdBy'?: string;
    'deviceName'?: string;
    'ipAddress'?: string;
    'userAgent'?: string;
    'trusted'?: boolean;
    'expiresIn'?: string;
    'revoked'?: boolean;
    'rememberMe'?: boolean;
    'lastLoginAt'?: string;
}
export interface DiagnosisRequest {
    'examinationId'?: string;
    'note'?: string;
    'icdCodeId'?: string;
}
export interface DiagnosisResponse {
    'id'?: string;
    'note'?: string;
    'icdCode'?: IcdCodeResponse;
}
export interface DispenseRecordRequest {
    'prescriptionId'?: string;
    'dispensedById'?: string;
    'status'?: DispenseRecordRequestStatusEnum;
    'dispensedAt'?: string;
    'totalCost'?: number;
    'note'?: string;
}

export const DispenseRecordRequestStatusEnum = {
    Pending: 'PENDING',
    Dispensed: 'DISPENSED',
    Cancelled: 'CANCELLED'
} as const;

export type DispenseRecordRequestStatusEnum = typeof DispenseRecordRequestStatusEnum[keyof typeof DispenseRecordRequestStatusEnum];

export interface DispenseRecordResponse {
    'id'?: string;
    'prescription'?: PrescriptionResponse;
    'dispensedBy'?: StaffResponse;
    'status'?: DispenseRecordResponseStatusEnum;
    'dispensedAt'?: string;
    'totalCost'?: number;
    'note'?: string;
    'patient'?: PatientResponse;
    'room'?: RoomResponse;
}

export const DispenseRecordResponseStatusEnum = {
    Pending: 'PENDING',
    Dispensed: 'DISPENSED',
    Cancelled: 'CANCELLED'
} as const;

export type DispenseRecordResponseStatusEnum = typeof DispenseRecordResponseStatusEnum[keyof typeof DispenseRecordResponseStatusEnum];

export interface EmergencyContactRequest {
    'fullName': string;
    'relationship'?: string;
    'phone'?: string;
}
export interface EmergencyContactResponse {
    'id'?: string;
    'fullName'?: string;
    'relationship'?: string;
    'phone'?: string;
}
export interface ExaminationRequest {
    'patientId'?: string;
    'staffId'?: string;
    'type'?: ExaminationRequestTypeEnum;
    'symptom'?: string;
    'diagnosisSummary'?: string;
}

export const ExaminationRequestTypeEnum = {
    General: 'GENERAL',
    Specialist: 'SPECIALIST',
    FollowUp: 'FOLLOW_UP',
    Emergency: 'EMERGENCY'
} as const;

export type ExaminationRequestTypeEnum = typeof ExaminationRequestTypeEnum[keyof typeof ExaminationRequestTypeEnum];

export interface ExaminationResponse {
    'id'?: string;
    'patient'?: PatientResponse;
    'staff'?: StaffResponse;
    'type'?: ExaminationResponseTypeEnum;
    'status'?: ExaminationResponseStatusEnum;
    'symptom'?: string;
    'diagnosisSummary'?: string;
    'examinationDate'?: string;
    'prescription'?: PrescriptionResponse;
    'serviceOrders'?: Set<ServiceOrderResponse>;
    'vitalSigns'?: Set<VitalSignResponse>;
    'diagnoses'?: Set<DiagnosisResponse>;
    'labOrders'?: Set<LabOrderResponse>;
}

export const ExaminationResponseTypeEnum = {
    General: 'GENERAL',
    Specialist: 'SPECIALIST',
    FollowUp: 'FOLLOW_UP',
    Emergency: 'EMERGENCY'
} as const;

export type ExaminationResponseTypeEnum = typeof ExaminationResponseTypeEnum[keyof typeof ExaminationResponseTypeEnum];
export const ExaminationResponseStatusEnum = {
    Ongoing: 'ONGOING',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED'
} as const;

export type ExaminationResponseStatusEnum = typeof ExaminationResponseStatusEnum[keyof typeof ExaminationResponseStatusEnum];

export interface FileAttachmentResponse {
    'id'?: string;
    'fileName'?: string;
    'contentType'?: string;
    'size'?: number;
    'url'?: string;
    'entityType'?: string;
    'entityId'?: string;
    'uploadPurpose'?: string;
}
export interface Filter {
    'field'?: string;
    'fields'?: Array<string>;
    'operator'?: string;
    'value'?: object;
    'empty'?: boolean;
}
export interface FilterGroup {
    'operator'?: FilterGroupOperatorEnum;
    'filters'?: Array<Filter>;
    'subGroups'?: Array<FilterGroup>;
    'empty'?: boolean;
}

export const FilterGroupOperatorEnum = {
    And: 'AND',
    Or: 'OR',
    Not: 'NOT'
} as const;

export type FilterGroupOperatorEnum = typeof FilterGroupOperatorEnum[keyof typeof FilterGroupOperatorEnum];

export interface FinishLoginRequest {
    'requestId'?: string;
    'deviceId'?: string;
    'rememberMe'?: boolean;
    'responseJson'?: string;
}
export interface FinishPasskeyRegistrationRequest {
    'credential'?: string;
}
export interface FirstLoginRequest {
    'username': string;
    'newPassword': string;
}
/**
 * @type GetServiceOrderDetail400Response
 */
export type GetServiceOrderDetail400Response = CustomApiResponseObject | CustomApiResponseVoid;

export interface IcdCodeRequest {
    'code'?: string;
    'name'?: string;
    'description'?: string;
    'chapter'?: string;
    'icdVersion'?: string;
}
export interface IcdCodeResponse {
    'id'?: string;
    'code'?: string;
    'name'?: string;
    'description'?: string;
    'chapter'?: string;
    'icdVersion'?: string;
}
export interface InvoiceItemResponse {
    'id'?: string;
    'description'?: string;
    'quantity'?: number;
    'unitPrice'?: number;
    'totalPrice'?: number;
}
export interface InvoiceRequest {
    'patientId'?: string;
    'examinationId'?: string;
    'invoiceNumber'?: string;
    'issueDate'?: string;
    'totalAmount'?: number;
    'paid'?: boolean;
    'note'?: string;
}
export interface InvoiceResponse {
    'id'?: string;
    'patient'?: PatientResponse;
    'examination'?: ExaminationResponse;
    'invoiceNumber'?: string;
    'issueDate'?: string;
    'totalAmount'?: number;
    'paid'?: boolean;
    'note'?: string;
    'items'?: Set<InvoiceItemResponse>;
    'room'?: RoomResponse;
    'assignedStaff'?: StaffResponse;
}
export interface LabOrderRequest {
    'patientId'?: string;
    'requestedById'?: string;
    'examinationId'?: string;
    'status'?: LabOrderRequestStatusEnum;
    'orderCode'?: string;
}

export const LabOrderRequestStatusEnum = {
    Pending: 'PENDING',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED',
    Verified: 'VERIFIED',
    Cancelled: 'CANCELLED'
} as const;

export type LabOrderRequestStatusEnum = typeof LabOrderRequestStatusEnum[keyof typeof LabOrderRequestStatusEnum];

export interface LabOrderResponse {
    'id'?: string;
    'patient'?: PatientResponse;
    'requestedBy'?: StaffResponse;
    'examinationId'?: string;
    'status'?: LabOrderResponseStatusEnum;
    'orderCode'?: string;
    'results'?: Set<LabTestResultResponse>;
    'room'?: RoomResponse;
    'assignedStaff'?: StaffResponse;
}

export const LabOrderResponseStatusEnum = {
    Pending: 'PENDING',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED',
    Verified: 'VERIFIED',
    Cancelled: 'CANCELLED'
} as const;

export type LabOrderResponseStatusEnum = typeof LabOrderResponseStatusEnum[keyof typeof LabOrderResponseStatusEnum];

export interface LabTestRequest {
    'code'?: string;
    'name'?: string;
    'category'?: string;
    'price'?: number;
    'unit'?: string;
    'referenceRange'?: string;
    'description'?: string;
    'roomType'?: LabTestRequestRoomTypeEnum;
}

export const LabTestRequestRoomTypeEnum = {
    Consultation: 'CONSULTATION',
    Xray: 'XRAY',
    Ultrasound: 'ULTRASOUND',
    Laboratory: 'LABORATORY',
    Procedure: 'PROCEDURE',
    Pharmacy: 'PHARMACY',
    Cashier: 'CASHIER',
    Reception: 'RECEPTION',
    WaitingArea: 'WAITING_AREA',
    Endoscopy: 'ENDOSCOPY',
    Ecg: 'ECG',
    Eeg: 'EEG',
    Dexa: 'DEXA',
    CtScan: 'CT_SCAN',
    Mri: 'MRI',
    Optometry: 'OPTOMETRY',
    Vaccination: 'VACCINATION',
    Physiotherapy: 'PHYSIOTHERAPY',
    Pft: 'PFT',
    MinorSurgery: 'MINOR_SURGERY'
} as const;

export type LabTestRequestRoomTypeEnum = typeof LabTestRequestRoomTypeEnum[keyof typeof LabTestRequestRoomTypeEnum];

export interface LabTestResponse {
    'id'?: string;
    'code'?: string;
    'name'?: string;
    'category'?: string;
    'price'?: number;
    'unit'?: string;
    'referenceRange'?: string;
    'description'?: string;
    'roomType'?: LabTestResponseRoomTypeEnum;
}

export const LabTestResponseRoomTypeEnum = {
    Consultation: 'CONSULTATION',
    Xray: 'XRAY',
    Ultrasound: 'ULTRASOUND',
    Laboratory: 'LABORATORY',
    Procedure: 'PROCEDURE',
    Pharmacy: 'PHARMACY',
    Cashier: 'CASHIER',
    Reception: 'RECEPTION',
    WaitingArea: 'WAITING_AREA',
    Endoscopy: 'ENDOSCOPY',
    Ecg: 'ECG',
    Eeg: 'EEG',
    Dexa: 'DEXA',
    CtScan: 'CT_SCAN',
    Mri: 'MRI',
    Optometry: 'OPTOMETRY',
    Vaccination: 'VACCINATION',
    Physiotherapy: 'PHYSIOTHERAPY',
    Pft: 'PFT',
    MinorSurgery: 'MINOR_SURGERY'
} as const;

export type LabTestResponseRoomTypeEnum = typeof LabTestResponseRoomTypeEnum[keyof typeof LabTestResponseRoomTypeEnum];

export interface LabTestResultRequest {
    'labOrderId'?: string;
    'labTestId'?: string;
    'status'?: LabTestResultRequestStatusEnum;
    'resultValue'?: string;
    'unit'?: string;
    'referenceRange'?: string;
    'remark'?: string;
    'verifiedById'?: string;
    'verifiedAt'?: string;
}

export const LabTestResultRequestStatusEnum = {
    Pending: 'PENDING',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED',
    Verified: 'VERIFIED',
    Cancelled: 'CANCELLED'
} as const;

export type LabTestResultRequestStatusEnum = typeof LabTestResultRequestStatusEnum[keyof typeof LabTestResultRequestStatusEnum];

export interface LabTestResultResponse {
    'id'?: string;
    'labTest'?: LabTestResponse;
    'status'?: LabTestResultResponseStatusEnum;
    'resultValue'?: string;
    'unit'?: string;
    'referenceRange'?: string;
    'remark'?: string;
    'verifiedBy'?: StaffResponse;
    'verifiedAt'?: string;
}

export const LabTestResultResponseStatusEnum = {
    Pending: 'PENDING',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED',
    Verified: 'VERIFIED',
    Cancelled: 'CANCELLED'
} as const;

export type LabTestResultResponseStatusEnum = typeof LabTestResultResponseStatusEnum[keyof typeof LabTestResultResponseStatusEnum];

export interface LargeBlobAuthenticationInput {
    'read'?: boolean;
    'write'?: string;
}
export interface LargeBlobRegistrationInput {
    'support'?: string;
}
export interface LocalTime {
    'hour'?: number;
    'minute'?: number;
    'second'?: number;
    'nano'?: number;
}
export interface LoginRequest {
    'username': string;
    'password': string;
    'deviceId': string;
    'rememberMe'?: boolean;
    'deviceName'?: string;
}
export interface MeResponse {
    'id'?: string;
    'username'?: string;
    'email'?: string;
    'phone'?: string;
    'active'?: boolean;
    'locked'?: boolean;
    'mfaEnabled'?: boolean;
    'userProfile'?: SimpleProfileResponse;
    'firstLogin'?: boolean;
    'roles'?: Set<RoleNameResponse>;
    'device'?: DeviceInfo;
    'staff'?: StaffResponse;
    'patient'?: PatientResponse;
    'room'?: RoomResponse;
}
export interface MedicineRequest {
    'code'?: string;
    'name'?: string;
    'activeIngredient'?: string;
    'dosageForm'?: string;
    'strength'?: string;
    'price'?: number;
    'unit'?: string;
    'description'?: string;
}
export interface MedicineResponse {
    'id'?: string;
    'code'?: string;
    'name'?: string;
    'activeIngredient'?: string;
    'dosageForm'?: string;
    'strength'?: string;
    'price'?: number;
    'unit'?: string;
    'description'?: string;
}
export interface MfaConfigResponse {
    'id'?: string;
    'createdDate'?: string;
    'mfaType'?: MfaConfigResponseMfaTypeEnum;
    'contact'?: string;
    'primary'?: boolean;
    'lastVerifiedAt'?: string;
    'deviceName'?: string;
    'revoked'?: boolean;
}

export const MfaConfigResponseMfaTypeEnum = {
    Totp: 'TOTP',
    Sms: 'SMS',
    Email: 'EMAIL',
    PushNotification: 'PUSH_NOTIFICATION',
    Passkey: 'PASSKEY',
    EmailVerification: 'EMAIL_VERIFICATION'
} as const;

export type MfaConfigResponseMfaTypeEnum = typeof MfaConfigResponseMfaTypeEnum[keyof typeof MfaConfigResponseMfaTypeEnum];

export interface MfaConfirmRequest {
    'challengeId': string;
    'code': string;
}
export interface MfaDeleteRequest {
    'configId': string;
    'verificationMethod': string;
    'code': string;
}
export interface MfaDisableRequest {
    'verificationMethod': string;
    'code': string;
}
export interface MfaEmailInitRequest {
    'email': string;
}
export interface MfaInitResponse {
    'challengeId'?: string;
}
export interface MfaSetupResponse {
    'secret'?: string;
    'qrUri'?: string;
}
export interface MfaVerifyRequest {
    'challengeId'?: string;
    'code': string;
    'deviceId': string;
    'rememberMe'?: boolean;
}
export interface OAuthAccountResponse {
    'createdDate'?: string;
    'provider'?: OAuthAccountResponseProviderEnum;
    'email'?: string;
    'name'?: string;
    'avatarUrl'?: string;
    'isRevoke'?: boolean;
}

export const OAuthAccountResponseProviderEnum = {
    Google: 'GOOGLE',
    Facebook: 'FACEBOOK',
    Github: 'GITHUB'
} as const;

export type OAuthAccountResponseProviderEnum = typeof OAuthAccountResponseProviderEnum[keyof typeof OAuthAccountResponseProviderEnum];

export interface OAuthLoginRequest {
    'provider': OAuthLoginRequestProviderEnum;
    'accessToken': string;
    'deviceId': string;
    'rememberMe'?: boolean;
    'deviceName'?: string;
}

export const OAuthLoginRequestProviderEnum = {
    Google: 'GOOGLE',
    Facebook: 'FACEBOOK',
    Github: 'GITHUB'
} as const;

export type OAuthLoginRequestProviderEnum = typeof OAuthLoginRequestProviderEnum[keyof typeof OAuthLoginRequestProviderEnum];

export interface PageObject {
    'totalPages'?: number;
    'totalElements'?: number;
    'pageable'?: PageableObject;
    'size'?: number;
    'content'?: Array<ServiceOrderResponse>;
    'number'?: number;
    'sort'?: SortObject;
    'first'?: boolean;
    'last'?: boolean;
    'numberOfElements'?: number;
    'empty'?: boolean;
}
export interface PageableObject {
    'pageNumber'?: number;
    'unpaged'?: boolean;
    'paged'?: boolean;
    'pageSize'?: number;
    'offset'?: number;
    'sort'?: SortObject;
}
export interface PasswordResetConfirmRequest {
    'token'?: string;
    'newPassword'?: string;
}
export interface PasswordResetRequest {
    'email'?: string;
}
export interface PatientByDayResponse {
    'year'?: number;
    'month'?: number;
    'day'?: number;
    'count'?: number;
}
export interface PatientByHourResponse {
    'hour'?: number;
    'count'?: number;
}
export interface PatientRequest {
    'fullName': string;
    'dateOfBirth'?: string;
    'gender'?: PatientRequestGenderEnum;
    'bloodType'?: PatientRequestBloodTypeEnum;
    'status'?: PatientRequestStatusEnum;
    'phone'?: string;
    'email'?: string;
    'address': string;
    'insuranceNumber'?: string;
}

export const PatientRequestGenderEnum = {
    Male: 'MALE',
    Female: 'FEMALE',
    Other: 'OTHER'
} as const;

export type PatientRequestGenderEnum = typeof PatientRequestGenderEnum[keyof typeof PatientRequestGenderEnum];
export const PatientRequestBloodTypeEnum = {
    APositive: 'A_POSITIVE',
    ANegative: 'A_NEGATIVE',
    BPositive: 'B_POSITIVE',
    BNegative: 'B_NEGATIVE',
    AbPositive: 'AB_POSITIVE',
    AbNegative: 'AB_NEGATIVE',
    OPositive: 'O_POSITIVE',
    ONegative: 'O_NEGATIVE'
} as const;

export type PatientRequestBloodTypeEnum = typeof PatientRequestBloodTypeEnum[keyof typeof PatientRequestBloodTypeEnum];
export const PatientRequestStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Deceased: 'DECEASED',
    Transferred: 'TRANSFERRED'
} as const;

export type PatientRequestStatusEnum = typeof PatientRequestStatusEnum[keyof typeof PatientRequestStatusEnum];

export interface PatientResponse {
    'id'?: string;
    'patientCode'?: string;
    'fullName'?: string;
    'dateOfBirth'?: string;
    'gender'?: PatientResponseGenderEnum;
    'bloodType'?: PatientResponseBloodTypeEnum;
    'status'?: PatientResponseStatusEnum;
    'phone'?: string;
    'email'?: string;
    'address'?: string;
    'insuranceNumber'?: string;
    'initPassword'?: string;
}

export const PatientResponseGenderEnum = {
    Male: 'MALE',
    Female: 'FEMALE',
    Other: 'OTHER'
} as const;

export type PatientResponseGenderEnum = typeof PatientResponseGenderEnum[keyof typeof PatientResponseGenderEnum];
export const PatientResponseBloodTypeEnum = {
    APositive: 'A_POSITIVE',
    ANegative: 'A_NEGATIVE',
    BPositive: 'B_POSITIVE',
    BNegative: 'B_NEGATIVE',
    AbPositive: 'AB_POSITIVE',
    AbNegative: 'AB_NEGATIVE',
    OPositive: 'O_POSITIVE',
    ONegative: 'O_NEGATIVE'
} as const;

export type PatientResponseBloodTypeEnum = typeof PatientResponseBloodTypeEnum[keyof typeof PatientResponseBloodTypeEnum];
export const PatientResponseStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Deceased: 'DECEASED',
    Transferred: 'TRANSFERRED'
} as const;

export type PatientResponseStatusEnum = typeof PatientResponseStatusEnum[keyof typeof PatientResponseStatusEnum];

export interface PermissionNameResponse {
    'name'?: string;
}
export interface PositionRequest {
    'positionCode'?: string;
    'title'?: string;
    'description'?: string;
}
export interface PositionResponse {
    'id'?: string;
    'positionCode'?: string;
    'title'?: string;
    'description'?: string;
}
export interface PrescriptionItemRequest {
    'prescriptionId'?: string;
    'medicineId'?: string;
    'dosage'?: string;
    'frequency'?: string;
    'duration'?: string;
    'instruction'?: string;
    'quantity'?: number;
}
export interface PrescriptionItemResponse {
    'id'?: string;
    'medicine'?: MedicineResponse;
    'dosage'?: string;
    'frequency'?: string;
    'duration'?: string;
    'instruction'?: string;
    'quantity'?: number;
}
export interface PrescriptionRequest {
    'examinationId'?: string;
    'note'?: string;
}
export interface PrescriptionResponse {
    'id'?: string;
    'note'?: string;
    'items'?: Set<PrescriptionItemResponse>;
}
export interface PrfAuthenticationInput {
    'eval'?: PrfValues;
    'evalByCredential'?: { [key: string]: PrfValues; };
}
export interface PrfRegistrationInput {
    'eval'?: PrfValues;
}
export interface PrfValues {
    'first'?: string;
    'second'?: string;
}
export interface PublicKeyCredentialCreationOptions {
    'rp'?: RelyingPartyIdentity;
    'user'?: UserIdentity;
    'challenge'?: string;
    'pubKeyCredParams'?: Array<PublicKeyCredentialParameters>;
    'timeout'?: number;
    'hints'?: Array<string>;
    'excludeCredentials'?: Set<PublicKeyCredentialDescriptor>;
    'authenticatorSelection'?: AuthenticatorSelectionCriteria;
    'attestation'?: PublicKeyCredentialCreationOptionsAttestationEnum;
    'extensions'?: RegistrationExtensionInputs;
}

export const PublicKeyCredentialCreationOptionsAttestationEnum = {
    None: 'none',
    Indirect: 'indirect',
    Direct: 'direct',
    Enterprise: 'enterprise'
} as const;

export type PublicKeyCredentialCreationOptionsAttestationEnum = typeof PublicKeyCredentialCreationOptionsAttestationEnum[keyof typeof PublicKeyCredentialCreationOptionsAttestationEnum];

export interface PublicKeyCredentialDescriptor {
    'type'?: PublicKeyCredentialDescriptorTypeEnum;
    'id'?: string;
    'transports'?: Set<string>;
}

export const PublicKeyCredentialDescriptorTypeEnum = {
    PublicKey: 'public-key'
} as const;

export type PublicKeyCredentialDescriptorTypeEnum = typeof PublicKeyCredentialDescriptorTypeEnum[keyof typeof PublicKeyCredentialDescriptorTypeEnum];

export interface PublicKeyCredentialParameters {
    'alg'?: PublicKeyCredentialParametersAlgEnum;
    'type'?: PublicKeyCredentialParametersTypeEnum;
}

export const PublicKeyCredentialParametersAlgEnum = {
    _8: '-8',
    _7: '-7',
    _35: '-35',
    _36: '-36',
    _257: '-257',
    _258: '-258',
    _259: '-259',
    _65535: '-65535'
} as const;

export type PublicKeyCredentialParametersAlgEnum = typeof PublicKeyCredentialParametersAlgEnum[keyof typeof PublicKeyCredentialParametersAlgEnum];
export const PublicKeyCredentialParametersTypeEnum = {
    PublicKey: 'public-key'
} as const;

export type PublicKeyCredentialParametersTypeEnum = typeof PublicKeyCredentialParametersTypeEnum[keyof typeof PublicKeyCredentialParametersTypeEnum];

export interface PublicKeyCredentialRequestOptions {
    'challenge'?: string;
    'timeout'?: number;
    'hints'?: Array<string>;
    'rpId'?: string;
    'allowCredentials'?: Array<PublicKeyCredentialDescriptor>;
    'userVerification'?: PublicKeyCredentialRequestOptionsUserVerificationEnum;
    'extensions'?: AssertionExtensionInputs;
}

export const PublicKeyCredentialRequestOptionsUserVerificationEnum = {
    Discouraged: 'discouraged',
    Preferred: 'preferred',
    Required: 'required'
} as const;

export type PublicKeyCredentialRequestOptionsUserVerificationEnum = typeof PublicKeyCredentialRequestOptionsUserVerificationEnum[keyof typeof PublicKeyCredentialRequestOptionsUserVerificationEnum];

export interface QueueTicketResponse {
    'id'?: string;
    'assignedDoctor'?: StaffResponse;
    'assignedRoom'?: RoomResponse;
    'queueNumber'?: string;
    'status'?: QueueTicketResponseStatusEnum;
    'priority'?: QueueTicketResponsePriorityEnum;
    'examinationId'?: string;
    'appointmentId'?: string;
    'appointmentPatient'?: PatientResponse;
    'appointmentSpecialty'?: SpecialtyResponse;
}

export const QueueTicketResponseStatusEnum = {
    Waiting: 'WAITING',
    Called: 'CALLED',
    InService: 'IN_SERVICE',
    InServiceWaitingResult: 'IN_SERVICE_WAITING_RESULT',
    WaitingAfterResult: 'WAITING_AFTER_RESULT',
    Skipped: 'SKIPPED',
    Done: 'DONE',
    Cancelled: 'CANCELLED'
} as const;

export type QueueTicketResponseStatusEnum = typeof QueueTicketResponseStatusEnum[keyof typeof QueueTicketResponseStatusEnum];
export const QueueTicketResponsePriorityEnum = {
    Normal: 'NORMAL',
    High: 'HIGH'
} as const;

export type QueueTicketResponsePriorityEnum = typeof QueueTicketResponsePriorityEnum[keyof typeof QueueTicketResponsePriorityEnum];

export interface RegisterRequest {
    'username'?: string;
    'fullName'?: string;
    'email'?: string;
    'password'?: string;
    'phone'?: string;
    'dob'?: string;
    'gender'?: RegisterRequestGenderEnum;
    'address'?: AddressResponse;
}

export const RegisterRequestGenderEnum = {
    Male: 'MALE',
    Female: 'FEMALE',
    Other: 'OTHER'
} as const;

export type RegisterRequestGenderEnum = typeof RegisterRequestGenderEnum[keyof typeof RegisterRequestGenderEnum];

export interface RegistrationExtensionInputs {
    'appidExclude'?: AppId;
    'credProps'?: boolean;
    'credentialProtectionPolicy'?: RegistrationExtensionInputsCredentialProtectionPolicyEnum;
    'enforceCredentialProtectionPolicy'?: boolean;
    'largeBlob'?: LargeBlobRegistrationInput;
    'prf'?: PrfRegistrationInput;
    'uvm'?: boolean;
}

export const RegistrationExtensionInputsCredentialProtectionPolicyEnum = {
    UserVerificationOptional: 'userVerificationOptional',
    UserVerificationOptionalWithCredentialIdList: 'userVerificationOptionalWithCredentialIDList',
    UserVerificationRequired: 'userVerificationRequired'
} as const;

export type RegistrationExtensionInputsCredentialProtectionPolicyEnum = typeof RegistrationExtensionInputsCredentialProtectionPolicyEnum[keyof typeof RegistrationExtensionInputsCredentialProtectionPolicyEnum];

export interface RelyingPartyIdentity {
    'name'?: string;
    'id'?: string;
}
export interface RevenueDailyResponse {
    'year'?: number;
    'month'?: number;
    'day'?: number;
    'revenue'?: number;
}
export interface RoleNameResponse {
    'name'?: string;
    'permissions'?: Set<PermissionNameResponse>;
}
export interface RoomRequest {
    'name': string;
    'roomType': RoomRequestRoomTypeEnum;
    'floorNumber'?: number;
    'capacity'?: number;
    'description'?: string;
    'departmentId': string;
}

export const RoomRequestRoomTypeEnum = {
    Consultation: 'CONSULTATION',
    Xray: 'XRAY',
    Ultrasound: 'ULTRASOUND',
    Laboratory: 'LABORATORY',
    Procedure: 'PROCEDURE',
    Pharmacy: 'PHARMACY',
    Cashier: 'CASHIER',
    Reception: 'RECEPTION',
    WaitingArea: 'WAITING_AREA',
    Endoscopy: 'ENDOSCOPY',
    Ecg: 'ECG',
    Eeg: 'EEG',
    Dexa: 'DEXA',
    CtScan: 'CT_SCAN',
    Mri: 'MRI',
    Optometry: 'OPTOMETRY',
    Vaccination: 'VACCINATION',
    Physiotherapy: 'PHYSIOTHERAPY',
    Pft: 'PFT',
    MinorSurgery: 'MINOR_SURGERY'
} as const;

export type RoomRequestRoomTypeEnum = typeof RoomRequestRoomTypeEnum[keyof typeof RoomRequestRoomTypeEnum];

export interface RoomResponse {
    'id'?: string;
    'name'?: string;
    'roomType'?: RoomResponseRoomTypeEnum;
    'floorNumber'?: number;
    'capacity'?: number;
    'description'?: string;
    'department'?: DepartmentSimpleResponse;
}

export const RoomResponseRoomTypeEnum = {
    Consultation: 'CONSULTATION',
    Xray: 'XRAY',
    Ultrasound: 'ULTRASOUND',
    Laboratory: 'LABORATORY',
    Procedure: 'PROCEDURE',
    Pharmacy: 'PHARMACY',
    Cashier: 'CASHIER',
    Reception: 'RECEPTION',
    WaitingArea: 'WAITING_AREA',
    Endoscopy: 'ENDOSCOPY',
    Ecg: 'ECG',
    Eeg: 'EEG',
    Dexa: 'DEXA',
    CtScan: 'CT_SCAN',
    Mri: 'MRI',
    Optometry: 'OPTOMETRY',
    Vaccination: 'VACCINATION',
    Physiotherapy: 'PHYSIOTHERAPY',
    Pft: 'PFT',
    MinorSurgery: 'MINOR_SURGERY'
} as const;

export type RoomResponseRoomTypeEnum = typeof RoomResponseRoomTypeEnum[keyof typeof RoomResponseRoomTypeEnum];

export interface SearchFilter {
    'page'?: number;
    'size'?: number;
    'sorts'?: Array<SortRequest>;
    'filterGroup'?: FilterGroup;
    'searchMode'?: SearchFilterSearchModeEnum;
}

export const SearchFilterSearchModeEnum = {
    SearchModeLucene: 'SearchMode.LUCENE',
    SearchModeJpa: 'SearchMode.JPA',
    SearchModeHybrid: 'SearchMode.HYBRID'
} as const;

export type SearchFilterSearchModeEnum = typeof SearchFilterSearchModeEnum[keyof typeof SearchFilterSearchModeEnum];

export interface ServiceCatalogRequest {
    'name'?: string;
    'category'?: string;
    'price'?: number;
    'description'?: string;
    'roomType'?: ServiceCatalogRequestRoomTypeEnum;
}

export const ServiceCatalogRequestRoomTypeEnum = {
    Consultation: 'CONSULTATION',
    Xray: 'XRAY',
    Ultrasound: 'ULTRASOUND',
    Laboratory: 'LABORATORY',
    Procedure: 'PROCEDURE',
    Pharmacy: 'PHARMACY',
    Cashier: 'CASHIER',
    Reception: 'RECEPTION',
    WaitingArea: 'WAITING_AREA',
    Endoscopy: 'ENDOSCOPY',
    Ecg: 'ECG',
    Eeg: 'EEG',
    Dexa: 'DEXA',
    CtScan: 'CT_SCAN',
    Mri: 'MRI',
    Optometry: 'OPTOMETRY',
    Vaccination: 'VACCINATION',
    Physiotherapy: 'PHYSIOTHERAPY',
    Pft: 'PFT',
    MinorSurgery: 'MINOR_SURGERY'
} as const;

export type ServiceCatalogRequestRoomTypeEnum = typeof ServiceCatalogRequestRoomTypeEnum[keyof typeof ServiceCatalogRequestRoomTypeEnum];

export interface ServiceCatalogResponse {
    'id'?: string;
    'code'?: string;
    'name'?: string;
    'category'?: string;
    'price'?: number;
    'description'?: string;
    'roomType'?: ServiceCatalogResponseRoomTypeEnum;
}

export const ServiceCatalogResponseRoomTypeEnum = {
    Consultation: 'CONSULTATION',
    Xray: 'XRAY',
    Ultrasound: 'ULTRASOUND',
    Laboratory: 'LABORATORY',
    Procedure: 'PROCEDURE',
    Pharmacy: 'PHARMACY',
    Cashier: 'CASHIER',
    Reception: 'RECEPTION',
    WaitingArea: 'WAITING_AREA',
    Endoscopy: 'ENDOSCOPY',
    Ecg: 'ECG',
    Eeg: 'EEG',
    Dexa: 'DEXA',
    CtScan: 'CT_SCAN',
    Mri: 'MRI',
    Optometry: 'OPTOMETRY',
    Vaccination: 'VACCINATION',
    Physiotherapy: 'PHYSIOTHERAPY',
    Pft: 'PFT',
    MinorSurgery: 'MINOR_SURGERY'
} as const;

export type ServiceCatalogResponseRoomTypeEnum = typeof ServiceCatalogResponseRoomTypeEnum[keyof typeof ServiceCatalogResponseRoomTypeEnum];

export interface ServiceOrderItemRequest {
    'serviceOrderId'?: string;
    'serviceId'?: string;
    'price'?: number;
    'note'?: string;
}
export interface ServiceOrderItemResponse {
    'id'?: string;
    'service'?: ServiceCatalogResponse;
    'price'?: number;
    'note'?: string;
}
export interface ServiceOrderRequest {
    'examinationId'?: string;
    'orderCode'?: string;
    'status'?: ServiceOrderRequestStatusEnum;
}

export const ServiceOrderRequestStatusEnum = {
    Pending: 'PENDING',
    Ready: 'READY',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED'
} as const;

export type ServiceOrderRequestStatusEnum = typeof ServiceOrderRequestStatusEnum[keyof typeof ServiceOrderRequestStatusEnum];

export interface ServiceOrderResponse {
    'id'?: string;
    'orderCode'?: string;
    'items'?: Set<ServiceOrderItemResponse>;
    'room'?: RoomResponse;
    'assignedStaff'?: StaffResponse;
    'status'?: ServiceOrderResponseStatusEnum;
    'examinationPatient'?: PatientResponse;
}

export const ServiceOrderResponseStatusEnum = {
    Pending: 'PENDING',
    Ready: 'READY',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED'
} as const;

export type ServiceOrderResponseStatusEnum = typeof ServiceOrderResponseStatusEnum[keyof typeof ServiceOrderResponseStatusEnum];

export interface ServiceUsageResponse {
    'serviceName'?: string;
    'category'?: string;
    'usedCount'?: number;
    'totalPrice'?: number;
}
export interface SimpleProfileResponse {
    'fullName'?: string;
    'avatarUrl'?: string;
}
export interface SortObject {
    'sorted'?: boolean;
    'unsorted'?: boolean;
    'empty'?: boolean;
}
export interface SortRequest {
    'field'?: string;
    'direction'?: SortRequestDirectionEnum;
}

export const SortRequestDirectionEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;

export type SortRequestDirectionEnum = typeof SortRequestDirectionEnum[keyof typeof SortRequestDirectionEnum];

export interface SpecialtyDistributionResponse {
    'specialty'?: string;
    'count'?: number;
}
export interface SpecialtyRequest {
    'departmentId'?: string;
    'name'?: string;
    'description'?: string;
}
export interface SpecialtyResponse {
    'id'?: string;
    'name'?: string;
    'description'?: string;
    'department'?: DepartmentResponse;
}
export interface StaffRequest {
    'phone'?: string;
    'fullName'?: string;
    'departmentId'?: string;
    'specialtyId'?: string;
    'staffType'?: StaffRequestStaffTypeEnum;
    'positionId'?: string;
    'licenseNumber'?: string;
    'experienceYears'?: number;
    'education'?: string;
    'bio'?: string;
    'joinedDate'?: string;
    'email'?: string;
}

export const StaffRequestStaffTypeEnum = {
    Doctor: 'DOCTOR',
    Nurse: 'NURSE',
    Technician: 'TECHNICIAN',
    LabTechnician: 'LAB_TECHNICIAN',
    Pharmacist: 'PHARMACIST',
    Receptionist: 'RECEPTIONIST',
    Cashier: 'CASHIER',
    Manager: 'MANAGER',
    SystemAdmin: 'SYSTEM_ADMIN'
} as const;

export type StaffRequestStaffTypeEnum = typeof StaffRequestStaffTypeEnum[keyof typeof StaffRequestStaffTypeEnum];

export interface StaffResponse {
    'specialty'?: SpecialtyResponse;
    'staffType'?: StaffResponseStaffTypeEnum;
    'position'?: PositionResponse;
    'licenseNumber'?: string;
    'experienceYears'?: number;
    'education'?: string;
    'bio'?: string;
    'joinedDate'?: string;
    'email'?: string;
    'department'?: DepartmentResponse;
    'id'?: string;
    'phone'?: string;
    'fullName'?: string;
}

export const StaffResponseStaffTypeEnum = {
    Doctor: 'DOCTOR',
    Nurse: 'NURSE',
    Technician: 'TECHNICIAN',
    LabTechnician: 'LAB_TECHNICIAN',
    Pharmacist: 'PHARMACIST',
    Receptionist: 'RECEPTIONIST',
    Cashier: 'CASHIER',
    Manager: 'MANAGER',
    SystemAdmin: 'SYSTEM_ADMIN'
} as const;

export type StaffResponseStaffTypeEnum = typeof StaffResponseStaffTypeEnum[keyof typeof StaffResponseStaffTypeEnum];

export interface StaffScheduleDayOffRequest {
    'staffId'?: string;
    'date'?: string;
    'startTime'?: LocalTime;
    'endTime'?: LocalTime;
    'roomId'?: string;
    'reason'?: string;
}
export interface StaffScheduleGenerateRequest {
    'staffId'?: string;
    'daysAhead'?: number;
}
export interface StaffScheduleRequest {
    'staffId'?: string;
    'dayOfWeek'?: StaffScheduleRequestDayOfWeekEnum;
    'startTime'?: LocalTime;
    'endTime'?: LocalTime;
    'available'?: boolean;
    'roomId'?: string;
    'date'?: string;
    'status'?: StaffScheduleRequestStatusEnum;
    'note'?: string;
}

export const StaffScheduleRequestDayOfWeekEnum = {
    Monday: 'MONDAY',
    Tuesday: 'TUESDAY',
    Wednesday: 'WEDNESDAY',
    Thursday: 'THURSDAY',
    Friday: 'FRIDAY',
    Saturday: 'SATURDAY',
    Sunday: 'SUNDAY'
} as const;

export type StaffScheduleRequestDayOfWeekEnum = typeof StaffScheduleRequestDayOfWeekEnum[keyof typeof StaffScheduleRequestDayOfWeekEnum];
export const StaffScheduleRequestStatusEnum = {
    Available: 'AVAILABLE',
    Off: 'OFF',
    Cancelled: 'CANCELLED',
    Changed: 'CHANGED'
} as const;

export type StaffScheduleRequestStatusEnum = typeof StaffScheduleRequestStatusEnum[keyof typeof StaffScheduleRequestStatusEnum];

export interface StaffScheduleResponse {
    'id'?: string;
    'dayOfWeek'?: StaffScheduleResponseDayOfWeekEnum;
    'startTime'?: LocalTime;
    'endTime'?: LocalTime;
    'available'?: boolean;
    'staff'?: StaffResponse;
    'room'?: RoomResponse;
    'date'?: string;
    'status'?: StaffScheduleResponseStatusEnum;
    'note'?: string;
}

export const StaffScheduleResponseDayOfWeekEnum = {
    Monday: 'MONDAY',
    Tuesday: 'TUESDAY',
    Wednesday: 'WEDNESDAY',
    Thursday: 'THURSDAY',
    Friday: 'FRIDAY',
    Saturday: 'SATURDAY',
    Sunday: 'SUNDAY'
} as const;

export type StaffScheduleResponseDayOfWeekEnum = typeof StaffScheduleResponseDayOfWeekEnum[keyof typeof StaffScheduleResponseDayOfWeekEnum];
export const StaffScheduleResponseStatusEnum = {
    Available: 'AVAILABLE',
    Off: 'OFF',
    Cancelled: 'CANCELLED',
    Changed: 'CHANGED'
} as const;

export type StaffScheduleResponseStatusEnum = typeof StaffScheduleResponseStatusEnum[keyof typeof StaffScheduleResponseStatusEnum];

export interface StaffScheduleTemplateRequest {
    'staffId'?: string;
    'staffStaffType'?: StaffScheduleTemplateRequestStaffStaffTypeEnum;
    'staffLicenseNumber'?: string;
    'staffExperienceYears'?: number;
    'staffEducation'?: string;
    'staffBio'?: string;
    'staffJoinedDate'?: string;
    'dayOfWeek'?: StaffScheduleTemplateRequestDayOfWeekEnum;
    'startTime'?: LocalTime;
    'endTime'?: LocalTime;
    'active'?: boolean;
    'roomId'?: string;
}

export const StaffScheduleTemplateRequestStaffStaffTypeEnum = {
    Doctor: 'DOCTOR',
    Nurse: 'NURSE',
    Technician: 'TECHNICIAN',
    LabTechnician: 'LAB_TECHNICIAN',
    Pharmacist: 'PHARMACIST',
    Receptionist: 'RECEPTIONIST',
    Cashier: 'CASHIER',
    Manager: 'MANAGER',
    SystemAdmin: 'SYSTEM_ADMIN'
} as const;

export type StaffScheduleTemplateRequestStaffStaffTypeEnum = typeof StaffScheduleTemplateRequestStaffStaffTypeEnum[keyof typeof StaffScheduleTemplateRequestStaffStaffTypeEnum];
export const StaffScheduleTemplateRequestDayOfWeekEnum = {
    Monday: 'MONDAY',
    Tuesday: 'TUESDAY',
    Wednesday: 'WEDNESDAY',
    Thursday: 'THURSDAY',
    Friday: 'FRIDAY',
    Saturday: 'SATURDAY',
    Sunday: 'SUNDAY'
} as const;

export type StaffScheduleTemplateRequestDayOfWeekEnum = typeof StaffScheduleTemplateRequestDayOfWeekEnum[keyof typeof StaffScheduleTemplateRequestDayOfWeekEnum];

export interface StaffScheduleTemplateResponse {
    'id'?: string;
    'dayOfWeek'?: StaffScheduleTemplateResponseDayOfWeekEnum;
    'startTime'?: LocalTime;
    'endTime'?: LocalTime;
    'active'?: boolean;
    'staff'?: StaffResponse;
    'room'?: RoomResponse;
}

export const StaffScheduleTemplateResponseDayOfWeekEnum = {
    Monday: 'MONDAY',
    Tuesday: 'TUESDAY',
    Wednesday: 'WEDNESDAY',
    Thursday: 'THURSDAY',
    Friday: 'FRIDAY',
    Saturday: 'SATURDAY',
    Sunday: 'SUNDAY'
} as const;

export type StaffScheduleTemplateResponseDayOfWeekEnum = typeof StaffScheduleTemplateResponseDayOfWeekEnum[keyof typeof StaffScheduleTemplateResponseDayOfWeekEnum];

export interface StaffWorkloadResponse {
    'id'?: string;
    'fullName'?: string;
    'workload'?: number;
}
export interface StartPasskeyLoginResponse {
    'requestId'?: string;
    'requestOptions'?: PublicKeyCredentialRequestOptions;
}
export interface SwitchMfaRequest {
    'mfaType'?: SwitchMfaRequestMfaTypeEnum;
    'challengeId'?: string;
}

export const SwitchMfaRequestMfaTypeEnum = {
    Totp: 'TOTP',
    Sms: 'SMS',
    Email: 'EMAIL',
    PushNotification: 'PUSH_NOTIFICATION',
    Passkey: 'PASSKEY',
    EmailVerification: 'EMAIL_VERIFICATION'
} as const;

export type SwitchMfaRequestMfaTypeEnum = typeof SwitchMfaRequestMfaTypeEnum[keyof typeof SwitchMfaRequestMfaTypeEnum];

export interface TOTPConfirmRequest {
    'code'?: string;
    'secret'?: string;
}
export interface TodaySummaryResponse {
    'totalPatients'?: number;
    'completedExams'?: number;
    'waitingPatients'?: number;
    'inService'?: number;
    'invoices'?: number;
    'totalRevenue'?: number;
    'labOrders'?: number;
    'imagingOrders'?: number;
    'avgWaitingMinutes'?: number;
}
export interface UpdateEmailRequest {
    'newEmail': string;
}
export interface UpdateUsernameRequest {
    'newUsername': string;
}
export interface UserIdentity {
    'name'?: string;
    'displayName'?: string;
    'id'?: string;
}
export interface UserProfileRequest {
    'fullName'?: string;
    'dateOfBirth'?: string;
    'address'?: AddressResponse;
    'phone'?: string;
    'avatarUrl'?: string;
}
export interface UserProfileResponse {
    'id'?: string;
    'createdDate'?: string;
    'lastModifiedDate'?: string;
    'userUsername'?: string;
    'userEmail'?: string;
    'phone'?: string;
    'fullName'?: string;
    'dateOfBirth'?: string;
    'address'?: AddressResponse;
    'avatarUrl'?: string;
}
export interface VitalSignRequest {
    'examinationId'?: string;
    'temperature'?: number;
    'bloodPressure'?: string;
    'pulse'?: number;
    'respirationRate'?: number;
    'height'?: number;
    'weight'?: number;
}
export interface VitalSignResponse {
    'id'?: string;
    'temperature'?: number;
    'bloodPressure'?: string;
    'pulse'?: number;
    'respirationRate'?: number;
    'height'?: number;
    'weight'?: number;
    'createdDate'?: string;
}

/**
 * AccountDeviceControllerApi - axios parameter creator
 */
export const AccountDeviceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDevices: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/account/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutAllDevices: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/account/devices/logout-all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} deviceSessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutDevice: async (deviceSessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceSessionId' is not null or undefined
            assertParamExists('logoutDevice', 'deviceSessionId', deviceSessionId)
            const localVarPath = `/api/account/devices/logout/{deviceSessionId}`
                .replace(`{${"deviceSessionId"}}`, encodeURIComponent(String(deviceSessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountDeviceControllerApi - functional programming interface
 */
export const AccountDeviceControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountDeviceControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllDevices(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseListDeviceSessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllDevices(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountDeviceControllerApi.getAllDevices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutAllDevices(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoutAllDevices(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountDeviceControllerApi.logoutAllDevices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} deviceSessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutDevice(deviceSessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoutDevice(deviceSessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountDeviceControllerApi.logoutDevice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountDeviceControllerApi - factory interface
 */
export const AccountDeviceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountDeviceControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDevices(options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseListDeviceSessionResponse> {
            return localVarFp.getAllDevices(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutAllDevices(options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.logoutAllDevices(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} deviceSessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutDevice(deviceSessionId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.logoutDevice(deviceSessionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountDeviceControllerApi - object-oriented interface
 */
export class AccountDeviceControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAllDevices(options?: RawAxiosRequestConfig) {
        return AccountDeviceControllerApiFp(this.configuration).getAllDevices(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public logoutAllDevices(options?: RawAxiosRequestConfig) {
        return AccountDeviceControllerApiFp(this.configuration).logoutAllDevices(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} deviceSessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public logoutDevice(deviceSessionId: string, options?: RawAxiosRequestConfig) {
        return AccountDeviceControllerApiFp(this.configuration).logoutDevice(deviceSessionId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AccountLoginActivityApi - axios parameter creator
 */
export const AccountLoginActivityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginHistory: async (searchFilter: SearchFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchFilter' is not null or undefined
            assertParamExists('getLoginHistory', 'searchFilter', searchFilter)
            const localVarPath = `/api/account/login-activity/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountLoginActivityApi - functional programming interface
 */
export const AccountLoginActivityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountLoginActivityApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLoginHistory(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePageLoginAttemptResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLoginHistory(searchFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountLoginActivityApi.getLoginHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountLoginActivityApi - factory interface
 */
export const AccountLoginActivityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountLoginActivityApiFp(configuration)
    return {
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginHistory(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePageLoginAttemptResponse> {
            return localVarFp.getLoginHistory(searchFilter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountLoginActivityApi - object-oriented interface
 */
export class AccountLoginActivityApi extends BaseAPI {
    /**
     * 
     * @param {SearchFilter} searchFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getLoginHistory(searchFilter: SearchFilter, options?: RawAxiosRequestConfig) {
        return AccountLoginActivityApiFp(this.configuration).getLoginHistory(searchFilter, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AccountProfileControllerApi - axios parameter creator
 */
export const AccountProfileControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/account/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAvatar: async (file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('updateAvatar', 'file', file)
            const localVarPath = `/api/account/profile/avatar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserProfileRequest} userProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfile: async (userProfileRequest: UserProfileRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userProfileRequest' is not null or undefined
            assertParamExists('updateProfile', 'userProfileRequest', userProfileRequest)
            const localVarPath = `/api/account/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountProfileControllerApi - functional programming interface
 */
export const AccountProfileControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountProfileControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseUserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfile(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountProfileControllerApi.getProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAvatar(file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseUserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAvatar(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountProfileControllerApi.updateAvatar']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UserProfileRequest} userProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProfile(userProfileRequest: UserProfileRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseUserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProfile(userProfileRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountProfileControllerApi.updateProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountProfileControllerApi - factory interface
 */
export const AccountProfileControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountProfileControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile(options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseUserProfileResponse> {
            return localVarFp.getProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAvatar(file: File, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseUserProfileResponse> {
            return localVarFp.updateAvatar(file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserProfileRequest} userProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfile(userProfileRequest: UserProfileRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseUserProfileResponse> {
            return localVarFp.updateProfile(userProfileRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountProfileControllerApi - object-oriented interface
 */
export class AccountProfileControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getProfile(options?: RawAxiosRequestConfig) {
        return AccountProfileControllerApiFp(this.configuration).getProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateAvatar(file: File, options?: RawAxiosRequestConfig) {
        return AccountProfileControllerApiFp(this.configuration).updateAvatar(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserProfileRequest} userProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateProfile(userProfileRequest: UserProfileRequest, options?: RawAxiosRequestConfig) {
        return AccountProfileControllerApiFp(this.configuration).updateProfile(userProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AccountSecurityControllerApi - axios parameter creator
 */
export const AccountSecurityControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ChangePasswordRequest} changePasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword: async (changePasswordRequest: ChangePasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changePasswordRequest' is not null or undefined
            assertParamExists('changePassword', 'changePasswordRequest', changePasswordRequest)
            const localVarPath = `/api/account/security/password/change`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changePasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MfaConfirmRequest} mfaConfirmRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmEmailMfa: async (mfaConfirmRequest: MfaConfirmRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mfaConfirmRequest' is not null or undefined
            assertParamExists('confirmEmailMfa', 'mfaConfirmRequest', mfaConfirmRequest)
            const localVarPath = `/api/account/security/mfa/email/confirm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaConfirmRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TOTPConfirmRequest} tOTPConfirmRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmTOTPSetup: async (tOTPConfirmRequest: TOTPConfirmRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tOTPConfirmRequest' is not null or undefined
            assertParamExists('confirmTOTPSetup', 'tOTPConfirmRequest', tOTPConfirmRequest)
            const localVarPath = `/api/account/security/mfa/totp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tOTPConfirmRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MfaDeleteRequest} mfaDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMfaConfig: async (mfaDeleteRequest: MfaDeleteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mfaDeleteRequest' is not null or undefined
            assertParamExists('deleteMfaConfig', 'mfaDeleteRequest', mfaDeleteRequest)
            const localVarPath = `/api/account/security/mfa/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MfaDisableRequest} mfaDisableRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableMfa: async (mfaDisableRequest: MfaDisableRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mfaDisableRequest' is not null or undefined
            assertParamExists('disableMfa', 'mfaDisableRequest', mfaDisableRequest)
            const localVarPath = `/api/account/security/mfa/disable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaDisableRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableMfa: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/account/security/mfa/enable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FinishPasskeyRegistrationRequest} finishPasskeyRegistrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finishRegistration1: async (finishPasskeyRegistrationRequest: FinishPasskeyRegistrationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'finishPasskeyRegistrationRequest' is not null or undefined
            assertParamExists('finishRegistration1', 'finishPasskeyRegistrationRequest', finishPasskeyRegistrationRequest)
            const localVarPath = `/api/account/security/mfa/passkey/registration/finish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(finishPasskeyRegistrationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FirstLoginRequest} firstLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        firstLogin: async (firstLoginRequest: FirstLoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'firstLoginRequest' is not null or undefined
            assertParamExists('firstLogin', 'firstLoginRequest', firstLoginRequest)
            const localVarPath = `/api/account/security/first-login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(firstLoginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateMfaBackupCodes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/account/security/mfa/backup-codes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMfaConfig: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/account/security/mfa`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MfaEmailInitRequest} mfaEmailInitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initEmailMfa: async (mfaEmailInitRequest: MfaEmailInitRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mfaEmailInitRequest' is not null or undefined
            assertParamExists('initEmailMfa', 'mfaEmailInitRequest', mfaEmailInitRequest)
            const localVarPath = `/api/account/security/mfa/email/init`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaEmailInitRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestTOTP: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/account/security/mfa/totp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRegistration1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/account/security/mfa/passkey/registration/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountSecurityControllerApi - functional programming interface
 */
export const AccountSecurityControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountSecurityControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ChangePasswordRequest} changePasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePassword(changePasswordRequest: ChangePasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(changePasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountSecurityControllerApi.changePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {MfaConfirmRequest} mfaConfirmRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmEmailMfa(mfaConfirmRequest: MfaConfirmRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseMfaConfigResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmEmailMfa(mfaConfirmRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountSecurityControllerApi.confirmEmailMfa']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {TOTPConfirmRequest} tOTPConfirmRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmTOTPSetup(tOTPConfirmRequest: TOTPConfirmRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmTOTPSetup(tOTPConfirmRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountSecurityControllerApi.confirmTOTPSetup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {MfaDeleteRequest} mfaDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMfaConfig(mfaDeleteRequest: MfaDeleteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMfaConfig(mfaDeleteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountSecurityControllerApi.deleteMfaConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {MfaDisableRequest} mfaDisableRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableMfa(mfaDisableRequest: MfaDisableRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableMfa(mfaDisableRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountSecurityControllerApi.disableMfa']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableMfa(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableMfa(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountSecurityControllerApi.enableMfa']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {FinishPasskeyRegistrationRequest} finishPasskeyRegistrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async finishRegistration1(finishPasskeyRegistrationRequest: FinishPasskeyRegistrationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.finishRegistration1(finishPasskeyRegistrationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountSecurityControllerApi.finishRegistration1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {FirstLoginRequest} firstLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async firstLogin(firstLoginRequest: FirstLoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.firstLogin(firstLoginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountSecurityControllerApi.firstLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateMfaBackupCodes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseListString>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateMfaBackupCodes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountSecurityControllerApi.generateMfaBackupCodes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMfaConfig(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseListMfaConfigResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMfaConfig(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountSecurityControllerApi.getMfaConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {MfaEmailInitRequest} mfaEmailInitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initEmailMfa(mfaEmailInitRequest: MfaEmailInitRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseMfaInitResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initEmailMfa(mfaEmailInitRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountSecurityControllerApi.initEmailMfa']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestTOTP(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseMfaSetupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestTOTP(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountSecurityControllerApi.requestTOTP']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startRegistration1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePublicKeyCredentialCreationOptions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startRegistration1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountSecurityControllerApi.startRegistration1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountSecurityControllerApi - factory interface
 */
export const AccountSecurityControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountSecurityControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {ChangePasswordRequest} changePasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(changePasswordRequest: ChangePasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.changePassword(changePasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MfaConfirmRequest} mfaConfirmRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmEmailMfa(mfaConfirmRequest: MfaConfirmRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseMfaConfigResponse> {
            return localVarFp.confirmEmailMfa(mfaConfirmRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TOTPConfirmRequest} tOTPConfirmRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmTOTPSetup(tOTPConfirmRequest: TOTPConfirmRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.confirmTOTPSetup(tOTPConfirmRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MfaDeleteRequest} mfaDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMfaConfig(mfaDeleteRequest: MfaDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.deleteMfaConfig(mfaDeleteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MfaDisableRequest} mfaDisableRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableMfa(mfaDisableRequest: MfaDisableRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.disableMfa(mfaDisableRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableMfa(options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.enableMfa(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FinishPasskeyRegistrationRequest} finishPasskeyRegistrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finishRegistration1(finishPasskeyRegistrationRequest: FinishPasskeyRegistrationRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.finishRegistration1(finishPasskeyRegistrationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FirstLoginRequest} firstLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        firstLogin(firstLoginRequest: FirstLoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.firstLogin(firstLoginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateMfaBackupCodes(options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseListString> {
            return localVarFp.generateMfaBackupCodes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMfaConfig(options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseListMfaConfigResponse> {
            return localVarFp.getMfaConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MfaEmailInitRequest} mfaEmailInitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initEmailMfa(mfaEmailInitRequest: MfaEmailInitRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseMfaInitResponse> {
            return localVarFp.initEmailMfa(mfaEmailInitRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestTOTP(options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseMfaSetupResponse> {
            return localVarFp.requestTOTP(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRegistration1(options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePublicKeyCredentialCreationOptions> {
            return localVarFp.startRegistration1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountSecurityControllerApi - object-oriented interface
 */
export class AccountSecurityControllerApi extends BaseAPI {
    /**
     * 
     * @param {ChangePasswordRequest} changePasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public changePassword(changePasswordRequest: ChangePasswordRequest, options?: RawAxiosRequestConfig) {
        return AccountSecurityControllerApiFp(this.configuration).changePassword(changePasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MfaConfirmRequest} mfaConfirmRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public confirmEmailMfa(mfaConfirmRequest: MfaConfirmRequest, options?: RawAxiosRequestConfig) {
        return AccountSecurityControllerApiFp(this.configuration).confirmEmailMfa(mfaConfirmRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TOTPConfirmRequest} tOTPConfirmRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public confirmTOTPSetup(tOTPConfirmRequest: TOTPConfirmRequest, options?: RawAxiosRequestConfig) {
        return AccountSecurityControllerApiFp(this.configuration).confirmTOTPSetup(tOTPConfirmRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MfaDeleteRequest} mfaDeleteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteMfaConfig(mfaDeleteRequest: MfaDeleteRequest, options?: RawAxiosRequestConfig) {
        return AccountSecurityControllerApiFp(this.configuration).deleteMfaConfig(mfaDeleteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MfaDisableRequest} mfaDisableRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public disableMfa(mfaDisableRequest: MfaDisableRequest, options?: RawAxiosRequestConfig) {
        return AccountSecurityControllerApiFp(this.configuration).disableMfa(mfaDisableRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public enableMfa(options?: RawAxiosRequestConfig) {
        return AccountSecurityControllerApiFp(this.configuration).enableMfa(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FinishPasskeyRegistrationRequest} finishPasskeyRegistrationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public finishRegistration1(finishPasskeyRegistrationRequest: FinishPasskeyRegistrationRequest, options?: RawAxiosRequestConfig) {
        return AccountSecurityControllerApiFp(this.configuration).finishRegistration1(finishPasskeyRegistrationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FirstLoginRequest} firstLoginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public firstLogin(firstLoginRequest: FirstLoginRequest, options?: RawAxiosRequestConfig) {
        return AccountSecurityControllerApiFp(this.configuration).firstLogin(firstLoginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public generateMfaBackupCodes(options?: RawAxiosRequestConfig) {
        return AccountSecurityControllerApiFp(this.configuration).generateMfaBackupCodes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMfaConfig(options?: RawAxiosRequestConfig) {
        return AccountSecurityControllerApiFp(this.configuration).getMfaConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MfaEmailInitRequest} mfaEmailInitRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public initEmailMfa(mfaEmailInitRequest: MfaEmailInitRequest, options?: RawAxiosRequestConfig) {
        return AccountSecurityControllerApiFp(this.configuration).initEmailMfa(mfaEmailInitRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public requestTOTP(options?: RawAxiosRequestConfig) {
        return AccountSecurityControllerApiFp(this.configuration).requestTOTP(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public startRegistration1(options?: RawAxiosRequestConfig) {
        return AccountSecurityControllerApiFp(this.configuration).startRegistration1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AccountSettingApi - axios parameter creator
 */
export const AccountSettingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/account/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateEmailRequest} updateEmailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailRequest: async (updateEmailRequest: UpdateEmailRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateEmailRequest' is not null or undefined
            assertParamExists('updateEmailRequest', 'updateEmailRequest', updateEmailRequest)
            const localVarPath = `/api/account/settings/email/request-change`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEmailRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateUsernameRequest} updateUsernameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsername: async (updateUsernameRequest: UpdateUsernameRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUsernameRequest' is not null or undefined
            assertParamExists('updateUsername', 'updateUsernameRequest', updateUsernameRequest)
            const localVarPath = `/api/account/settings/username`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUsernameRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmailChange: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('verifyEmailChange', 'token', token)
            const localVarPath = `/api/account/settings/email/verify-change`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountSettingApi - functional programming interface
 */
export const AccountSettingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountSettingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseAccountSettingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountSettingApi.getAccountSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateEmailRequest} updateEmailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEmailRequest(updateEmailRequest: UpdateEmailRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEmailRequest(updateEmailRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountSettingApi.updateEmailRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateUsernameRequest} updateUsernameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUsername(updateUsernameRequest: UpdateUsernameRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseAccountSettingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUsername(updateUsernameRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountSettingApi.updateUsername']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyEmailChange(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyEmailChange(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountSettingApi.verifyEmailChange']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountSettingApi - factory interface
 */
export const AccountSettingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountSettingApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountSettings(options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseAccountSettingResponse> {
            return localVarFp.getAccountSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateEmailRequest} updateEmailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailRequest(updateEmailRequest: UpdateEmailRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.updateEmailRequest(updateEmailRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateUsernameRequest} updateUsernameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsername(updateUsernameRequest: UpdateUsernameRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseAccountSettingResponse> {
            return localVarFp.updateUsername(updateUsernameRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmailChange(token: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.verifyEmailChange(token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountSettingApi - object-oriented interface
 */
export class AccountSettingApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAccountSettings(options?: RawAxiosRequestConfig) {
        return AccountSettingApiFp(this.configuration).getAccountSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateEmailRequest} updateEmailRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateEmailRequest(updateEmailRequest: UpdateEmailRequest, options?: RawAxiosRequestConfig) {
        return AccountSettingApiFp(this.configuration).updateEmailRequest(updateEmailRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateUsernameRequest} updateUsernameRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateUsername(updateUsernameRequest: UpdateUsernameRequest, options?: RawAxiosRequestConfig) {
        return AccountSettingApiFp(this.configuration).updateUsername(updateUsernameRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public verifyEmailChange(token: string, options?: RawAxiosRequestConfig) {
        return AccountSettingApiFp(this.configuration).verifyEmailChange(token, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdministrativeUnitControllerApi - axios parameter creator
 */
export const AdministrativeUnitControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {GetAdministrativeUnitsLevelEnum} level 
         * @param {string} [parentCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdministrativeUnits: async (level: GetAdministrativeUnitsLevelEnum, parentCode?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'level' is not null or undefined
            assertParamExists('getAdministrativeUnits', 'level', level)
            const localVarPath = `/api/common/administrative-units`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (parentCode !== undefined) {
                localVarQueryParameter['parentCode'] = parentCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdministrativeUnitControllerApi - functional programming interface
 */
export const AdministrativeUnitControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdministrativeUnitControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {GetAdministrativeUnitsLevelEnum} level 
         * @param {string} [parentCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdministrativeUnits(level: GetAdministrativeUnitsLevelEnum, parentCode?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseListAdministrativeUnitResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAdministrativeUnits(level, parentCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdministrativeUnitControllerApi.getAdministrativeUnits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdministrativeUnitControllerApi - factory interface
 */
export const AdministrativeUnitControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdministrativeUnitControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {GetAdministrativeUnitsLevelEnum} level 
         * @param {string} [parentCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdministrativeUnits(level: GetAdministrativeUnitsLevelEnum, parentCode?: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseListAdministrativeUnitResponse> {
            return localVarFp.getAdministrativeUnits(level, parentCode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdministrativeUnitControllerApi - object-oriented interface
 */
export class AdministrativeUnitControllerApi extends BaseAPI {
    /**
     * 
     * @param {GetAdministrativeUnitsLevelEnum} level 
     * @param {string} [parentCode] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAdministrativeUnits(level: GetAdministrativeUnitsLevelEnum, parentCode?: string, options?: RawAxiosRequestConfig) {
        return AdministrativeUnitControllerApiFp(this.configuration).getAdministrativeUnits(level, parentCode, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetAdministrativeUnitsLevelEnum = {
    Province: 'PROVINCE',
    District: 'DISTRICT',
    Ward: 'WARD'
} as const;
export type GetAdministrativeUnitsLevelEnum = typeof GetAdministrativeUnitsLevelEnum[keyof typeof GetAdministrativeUnitsLevelEnum];


/**
 * AppointmentManagementApi - axios parameter creator
 */
export const AppointmentManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AppointmentRequest} appointmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create10: async (appointmentRequest: AppointmentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appointmentRequest' is not null or undefined
            assertParamExists('create10', 'appointmentRequest', appointmentRequest)
            const localVarPath = `/api/appointments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(appointmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} appointmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete10: async (appointmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appointmentId' is not null or undefined
            assertParamExists('delete10', 'appointmentId', appointmentId)
            const localVarPath = `/api/appointments/{appointmentId}`
                .replace(`{${"appointmentId"}}`, encodeURIComponent(String(appointmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filter11: async (searchFilter: SearchFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchFilter' is not null or undefined
            assertParamExists('filter11', 'searchFilter', searchFilter)
            const localVarPath = `/api/appointments/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} appointmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById6: async (appointmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appointmentId' is not null or undefined
            assertParamExists('getById6', 'appointmentId', appointmentId)
            const localVarPath = `/api/appointments/{appointmentId}`
                .replace(`{${"appointmentId"}}`, encodeURIComponent(String(appointmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} appointmentId 
         * @param {AppointmentRequest} appointmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update10: async (appointmentId: string, appointmentRequest: AppointmentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appointmentId' is not null or undefined
            assertParamExists('update10', 'appointmentId', appointmentId)
            // verify required parameter 'appointmentRequest' is not null or undefined
            assertParamExists('update10', 'appointmentRequest', appointmentRequest)
            const localVarPath = `/api/appointments/{appointmentId}`
                .replace(`{${"appointmentId"}}`, encodeURIComponent(String(appointmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(appointmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppointmentManagementApi - functional programming interface
 */
export const AppointmentManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AppointmentManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AppointmentRequest} appointmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create10(appointmentRequest: AppointmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseAppointmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create10(appointmentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppointmentManagementApi.create10']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} appointmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete10(appointmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete10(appointmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppointmentManagementApi.delete10']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filter11(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePageAppointmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filter11(searchFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppointmentManagementApi.filter11']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} appointmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById6(appointmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseAppointmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById6(appointmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppointmentManagementApi.getById6']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} appointmentId 
         * @param {AppointmentRequest} appointmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update10(appointmentId: string, appointmentRequest: AppointmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseAppointmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update10(appointmentId, appointmentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppointmentManagementApi.update10']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AppointmentManagementApi - factory interface
 */
export const AppointmentManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AppointmentManagementApiFp(configuration)
    return {
        /**
         * 
         * @param {AppointmentRequest} appointmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create10(appointmentRequest: AppointmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseAppointmentResponse> {
            return localVarFp.create10(appointmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} appointmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete10(appointmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.delete10(appointmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filter11(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePageAppointmentResponse> {
            return localVarFp.filter11(searchFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} appointmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById6(appointmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseAppointmentResponse> {
            return localVarFp.getById6(appointmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} appointmentId 
         * @param {AppointmentRequest} appointmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update10(appointmentId: string, appointmentRequest: AppointmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseAppointmentResponse> {
            return localVarFp.update10(appointmentId, appointmentRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AppointmentManagementApi - object-oriented interface
 */
export class AppointmentManagementApi extends BaseAPI {
    /**
     * 
     * @param {AppointmentRequest} appointmentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public create10(appointmentRequest: AppointmentRequest, options?: RawAxiosRequestConfig) {
        return AppointmentManagementApiFp(this.configuration).create10(appointmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} appointmentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public delete10(appointmentId: string, options?: RawAxiosRequestConfig) {
        return AppointmentManagementApiFp(this.configuration).delete10(appointmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SearchFilter} searchFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public filter11(searchFilter: SearchFilter, options?: RawAxiosRequestConfig) {
        return AppointmentManagementApiFp(this.configuration).filter11(searchFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} appointmentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getById6(appointmentId: string, options?: RawAxiosRequestConfig) {
        return AppointmentManagementApiFp(this.configuration).getById6(appointmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} appointmentId 
     * @param {AppointmentRequest} appointmentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public update10(appointmentId: string, appointmentRequest: AppointmentRequest, options?: RawAxiosRequestConfig) {
        return AppointmentManagementApiFp(this.configuration).update10(appointmentId, appointmentRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthenticationApi - axios parameter creator
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAccount: async (body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('activateAccount', 'body', body)
            const localVarPath = `/api/auth/activate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PasswordResetConfirmRequest} passwordResetConfirmRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmPasswordReset: async (passwordResetConfirmRequest: PasswordResetConfirmRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordResetConfirmRequest' is not null or undefined
            assertParamExists('confirmPasswordReset', 'passwordResetConfirmRequest', passwordResetConfirmRequest)
            const localVarPath = `/api/auth/password/reset/confirm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordResetConfirmRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('login', 'loginRequest', loginRequest)
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OAuthLoginRequest} oAuthLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginWithOAuth: async (oAuthLoginRequest: OAuthLoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oAuthLoginRequest' is not null or undefined
            assertParamExists('loginWithOAuth', 'oAuthLoginRequest', oAuthLoginRequest)
            const localVarPath = `/api/auth/oauth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oAuthLoginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (registerRequest: RegisterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerRequest' is not null or undefined
            assertParamExists('register', 'registerRequest', registerRequest)
            const localVarPath = `/api/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PasswordResetRequest} passwordResetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestPasswordReset: async (passwordResetRequest: PasswordResetRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordResetRequest' is not null or undefined
            assertParamExists('requestPasswordReset', 'passwordResetRequest', passwordResetRequest)
            const localVarPath = `/api/auth/password/reset/request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordResetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SwitchMfaRequest} switchMfaRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        switchMfa: async (switchMfaRequest: SwitchMfaRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'switchMfaRequest' is not null or undefined
            assertParamExists('switchMfa', 'switchMfaRequest', switchMfaRequest)
            const localVarPath = `/api/auth/mfa/switch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(switchMfaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MfaVerifyRequest} mfaVerifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyMfa: async (mfaVerifyRequest: MfaVerifyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mfaVerifyRequest' is not null or undefined
            assertParamExists('verifyMfa', 'mfaVerifyRequest', mfaVerifyRequest)
            const localVarPath = `/api/auth/mfa/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mfaVerifyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateAccount(body: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseString>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateAccount(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.activateAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PasswordResetConfirmRequest} passwordResetConfirmRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmPasswordReset(passwordResetConfirmRequest: PasswordResetConfirmRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmPasswordReset(passwordResetConfirmRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.confirmPasswordReset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseMeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.getCurrentUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseAuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {OAuthLoginRequest} oAuthLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginWithOAuth(oAuthLoginRequest: OAuthLoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseAuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginWithOAuth(oAuthLoginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.loginWithOAuth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.logout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseAuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.refreshToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseAuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(registerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.register']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PasswordResetRequest} passwordResetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestPasswordReset(passwordResetRequest: PasswordResetRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestPasswordReset(passwordResetRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.requestPasswordReset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SwitchMfaRequest} switchMfaRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async switchMfa(switchMfaRequest: SwitchMfaRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseAuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.switchMfa(switchMfaRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.switchMfa']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {MfaVerifyRequest} mfaVerifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyMfa(mfaVerifyRequest: MfaVerifyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseAuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyMfa(mfaVerifyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.verifyMfa']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAccount(body: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseString> {
            return localVarFp.activateAccount(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PasswordResetConfirmRequest} passwordResetConfirmRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmPasswordReset(passwordResetConfirmRequest: PasswordResetConfirmRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.confirmPasswordReset(passwordResetConfirmRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseMeResponse> {
            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseAuthResponse> {
            return localVarFp.login(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OAuthLoginRequest} oAuthLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginWithOAuth(oAuthLoginRequest: OAuthLoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseAuthResponse> {
            return localVarFp.loginWithOAuth(oAuthLoginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseAuthResponse> {
            return localVarFp.refreshToken(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseAuthResponse> {
            return localVarFp.register(registerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PasswordResetRequest} passwordResetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestPasswordReset(passwordResetRequest: PasswordResetRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.requestPasswordReset(passwordResetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SwitchMfaRequest} switchMfaRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        switchMfa(switchMfaRequest: SwitchMfaRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseAuthResponse> {
            return localVarFp.switchMfa(switchMfaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MfaVerifyRequest} mfaVerifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyMfa(mfaVerifyRequest: MfaVerifyRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseAuthResponse> {
            return localVarFp.verifyMfa(mfaVerifyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * 
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public activateAccount(body: string, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).activateAccount(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PasswordResetConfirmRequest} passwordResetConfirmRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public confirmPasswordReset(passwordResetConfirmRequest: PasswordResetConfirmRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).confirmPasswordReset(passwordResetConfirmRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCurrentUser(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).login(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OAuthLoginRequest} oAuthLoginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public loginWithOAuth(oAuthLoginRequest: OAuthLoginRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).loginWithOAuth(oAuthLoginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public logout(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public refreshToken(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).refreshToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RegisterRequest} registerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public register(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).register(registerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PasswordResetRequest} passwordResetRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public requestPasswordReset(passwordResetRequest: PasswordResetRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).requestPasswordReset(passwordResetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SwitchMfaRequest} switchMfaRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public switchMfa(switchMfaRequest: SwitchMfaRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).switchMfa(switchMfaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MfaVerifyRequest} mfaVerifyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public verifyMfa(mfaVerifyRequest: MfaVerifyRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).verifyMfa(mfaVerifyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CMSApi - axios parameter creator
 */
export const CMSApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archive: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('archive', 'id', id)
            const localVarPath = `/api/cms/contents/{id}/archive`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ContentRequest} contentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create9: async (contentRequest: ContentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentRequest' is not null or undefined
            assertParamExists('create9', 'contentRequest', contentRequest)
            const localVarPath = `/api/cms/contents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete9: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('delete9', 'id', id)
            const localVarPath = `/api/cms/contents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filter10: async (searchFilter: SearchFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchFilter' is not null or undefined
            assertParamExists('filter10', 'searchFilter', searchFilter)
            const localVarPath = `/api/cms/contents/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById5: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getById5', 'id', id)
            const localVarPath = `/api/cms/contents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBySlug: async (slug: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('getBySlug', 'slug', slug)
            const localVarPath = `/api/cms/contents/slug/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publish: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('publish', 'id', id)
            const localVarPath = `/api/cms/contents/{id}/publish`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {ContentRequest} contentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update9: async (id: string, contentRequest: ContentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update9', 'id', id)
            // verify required parameter 'contentRequest' is not null or undefined
            assertParamExists('update9', 'contentRequest', contentRequest)
            const localVarPath = `/api/cms/contents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CMSApi - functional programming interface
 */
export const CMSApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CMSApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archive(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseContentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.archive(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CMSApi.archive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ContentRequest} contentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create9(contentRequest: ContentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseContentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create9(contentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CMSApi.create9']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete9(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete9(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CMSApi.delete9']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filter10(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePageContentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filter10(searchFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CMSApi.filter10']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById5(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseContentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById5(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CMSApi.getById5']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBySlug(slug: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseContentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBySlug(slug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CMSApi.getBySlug']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publish(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseContentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publish(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CMSApi.publish']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {ContentRequest} contentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update9(id: string, contentRequest: ContentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseContentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update9(id, contentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CMSApi.update9']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CMSApi - factory interface
 */
export const CMSApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CMSApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archive(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseContentResponse> {
            return localVarFp.archive(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ContentRequest} contentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create9(contentRequest: ContentRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseContentResponse> {
            return localVarFp.create9(contentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete9(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.delete9(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filter10(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePageContentResponse> {
            return localVarFp.filter10(searchFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById5(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseContentResponse> {
            return localVarFp.getById5(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBySlug(slug: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseContentResponse> {
            return localVarFp.getBySlug(slug, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publish(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseContentResponse> {
            return localVarFp.publish(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {ContentRequest} contentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update9(id: string, contentRequest: ContentRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseContentResponse> {
            return localVarFp.update9(id, contentRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CMSApi - object-oriented interface
 */
export class CMSApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public archive(id: string, options?: RawAxiosRequestConfig) {
        return CMSApiFp(this.configuration).archive(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ContentRequest} contentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public create9(contentRequest: ContentRequest, options?: RawAxiosRequestConfig) {
        return CMSApiFp(this.configuration).create9(contentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public delete9(id: string, options?: RawAxiosRequestConfig) {
        return CMSApiFp(this.configuration).delete9(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SearchFilter} searchFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public filter10(searchFilter: SearchFilter, options?: RawAxiosRequestConfig) {
        return CMSApiFp(this.configuration).filter10(searchFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getById5(id: string, options?: RawAxiosRequestConfig) {
        return CMSApiFp(this.configuration).getById5(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} slug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getBySlug(slug: string, options?: RawAxiosRequestConfig) {
        return CMSApiFp(this.configuration).getBySlug(slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public publish(id: string, options?: RawAxiosRequestConfig) {
        return CMSApiFp(this.configuration).publish(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {ContentRequest} contentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public update9(id: string, contentRequest: ContentRequest, options?: RawAxiosRequestConfig) {
        return CMSApiFp(this.configuration).update9(id, contentRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClinicManagementApi - axios parameter creator
 */
export const ClinicManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ClinicRequest} clinicRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create2: async (clinicRequest: ClinicRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clinicRequest' is not null or undefined
            assertParamExists('create2', 'clinicRequest', clinicRequest)
            const localVarPath = `/api/organization/clinics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clinicRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete2: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('delete2', 'id', id)
            const localVarPath = `/api/organization/clinics/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filter3: async (searchFilter: SearchFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchFilter' is not null or undefined
            assertParamExists('filter3', 'searchFilter', searchFilter)
            const localVarPath = `/api/organization/clinics/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} clinicId 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filterDepartmentsByClinic: async (clinicId: string, searchFilter: SearchFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clinicId' is not null or undefined
            assertParamExists('filterDepartmentsByClinic', 'clinicId', clinicId)
            // verify required parameter 'searchFilter' is not null or undefined
            assertParamExists('filterDepartmentsByClinic', 'searchFilter', searchFilter)
            const localVarPath = `/api/organization/clinics/{clinicId}/departments/filter`
                .replace(`{${"clinicId"}}`, encodeURIComponent(String(clinicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClinicById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getClinicById', 'id', id)
            const localVarPath = `/api/organization/clinics/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultClinic: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/organization/clinics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {ClinicRequest} clinicRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update2: async (id: string, clinicRequest: ClinicRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update2', 'id', id)
            // verify required parameter 'clinicRequest' is not null or undefined
            assertParamExists('update2', 'clinicRequest', clinicRequest)
            const localVarPath = `/api/organization/clinics/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clinicRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClinicManagementApi - functional programming interface
 */
export const ClinicManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClinicManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ClinicRequest} clinicRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create2(clinicRequest: ClinicRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseClinicResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create2(clinicRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClinicManagementApi.create2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete2(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete2(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClinicManagementApi.delete2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filter3(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePageClinicResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filter3(searchFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClinicManagementApi.filter3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} clinicId 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filterDepartmentsByClinic(clinicId: string, searchFilter: SearchFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePageDepartmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filterDepartmentsByClinic(clinicId, searchFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClinicManagementApi.filterDepartmentsByClinic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClinicById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseClinicResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClinicById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClinicManagementApi.getClinicById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultClinic(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseClinicResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultClinic(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClinicManagementApi.getDefaultClinic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {ClinicRequest} clinicRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update2(id: string, clinicRequest: ClinicRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseClinicResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update2(id, clinicRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClinicManagementApi.update2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClinicManagementApi - factory interface
 */
export const ClinicManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClinicManagementApiFp(configuration)
    return {
        /**
         * 
         * @param {ClinicRequest} clinicRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create2(clinicRequest: ClinicRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseClinicResponse> {
            return localVarFp.create2(clinicRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete2(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.delete2(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filter3(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePageClinicResponse> {
            return localVarFp.filter3(searchFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} clinicId 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filterDepartmentsByClinic(clinicId: string, searchFilter: SearchFilter, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePageDepartmentResponse> {
            return localVarFp.filterDepartmentsByClinic(clinicId, searchFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClinicById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseClinicResponse> {
            return localVarFp.getClinicById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultClinic(options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseClinicResponse> {
            return localVarFp.getDefaultClinic(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {ClinicRequest} clinicRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update2(id: string, clinicRequest: ClinicRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseClinicResponse> {
            return localVarFp.update2(id, clinicRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClinicManagementApi - object-oriented interface
 */
export class ClinicManagementApi extends BaseAPI {
    /**
     * 
     * @param {ClinicRequest} clinicRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public create2(clinicRequest: ClinicRequest, options?: RawAxiosRequestConfig) {
        return ClinicManagementApiFp(this.configuration).create2(clinicRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public delete2(id: string, options?: RawAxiosRequestConfig) {
        return ClinicManagementApiFp(this.configuration).delete2(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SearchFilter} searchFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public filter3(searchFilter: SearchFilter, options?: RawAxiosRequestConfig) {
        return ClinicManagementApiFp(this.configuration).filter3(searchFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} clinicId 
     * @param {SearchFilter} searchFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public filterDepartmentsByClinic(clinicId: string, searchFilter: SearchFilter, options?: RawAxiosRequestConfig) {
        return ClinicManagementApiFp(this.configuration).filterDepartmentsByClinic(clinicId, searchFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getClinicById(id: string, options?: RawAxiosRequestConfig) {
        return ClinicManagementApiFp(this.configuration).getClinicById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDefaultClinic(options?: RawAxiosRequestConfig) {
        return ClinicManagementApiFp(this.configuration).getDefaultClinic(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {ClinicRequest} clinicRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public update2(id: string, clinicRequest: ClinicRequest, options?: RawAxiosRequestConfig) {
        return ClinicManagementApiFp(this.configuration).update2(id, clinicRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DepartmentManagementApi - axios parameter creator
 */
export const DepartmentManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DepartmentRequest} departmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create1: async (departmentRequest: DepartmentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'departmentRequest' is not null or undefined
            assertParamExists('create1', 'departmentRequest', departmentRequest)
            const localVarPath = `/api/organization/departments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(departmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('delete1', 'id', id)
            const localVarPath = `/api/organization/departments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filter2: async (searchFilter: SearchFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchFilter' is not null or undefined
            assertParamExists('filter2', 'searchFilter', searchFilter)
            const localVarPath = `/api/organization/departments/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} deptId 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filterRoomsByDepartment: async (deptId: string, searchFilter: SearchFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deptId' is not null or undefined
            assertParamExists('filterRoomsByDepartment', 'deptId', deptId)
            // verify required parameter 'searchFilter' is not null or undefined
            assertParamExists('filterRoomsByDepartment', 'searchFilter', searchFilter)
            const localVarPath = `/api/organization/departments/{deptId}/rooms`
                .replace(`{${"deptId"}}`, encodeURIComponent(String(deptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepartmentById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDepartmentById', 'id', id)
            const localVarPath = `/api/organization/departments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {DepartmentRequest} departmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update1: async (id: string, departmentRequest: DepartmentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update1', 'id', id)
            // verify required parameter 'departmentRequest' is not null or undefined
            assertParamExists('update1', 'departmentRequest', departmentRequest)
            const localVarPath = `/api/organization/departments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(departmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DepartmentManagementApi - functional programming interface
 */
export const DepartmentManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DepartmentManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {DepartmentRequest} departmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create1(departmentRequest: DepartmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseDepartmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create1(departmentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepartmentManagementApi.create1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepartmentManagementApi.delete1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filter2(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePageDepartmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filter2(searchFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepartmentManagementApi.filter2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} deptId 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filterRoomsByDepartment(deptId: string, searchFilter: SearchFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePageRoomResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filterRoomsByDepartment(deptId, searchFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepartmentManagementApi.filterRoomsByDepartment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepartmentById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseDepartmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDepartmentById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepartmentManagementApi.getDepartmentById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {DepartmentRequest} departmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update1(id: string, departmentRequest: DepartmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseDepartmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update1(id, departmentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepartmentManagementApi.update1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DepartmentManagementApi - factory interface
 */
export const DepartmentManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DepartmentManagementApiFp(configuration)
    return {
        /**
         * 
         * @param {DepartmentRequest} departmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create1(departmentRequest: DepartmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseDepartmentResponse> {
            return localVarFp.create1(departmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.delete1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filter2(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePageDepartmentResponse> {
            return localVarFp.filter2(searchFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} deptId 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filterRoomsByDepartment(deptId: string, searchFilter: SearchFilter, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePageRoomResponse> {
            return localVarFp.filterRoomsByDepartment(deptId, searchFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepartmentById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseDepartmentResponse> {
            return localVarFp.getDepartmentById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {DepartmentRequest} departmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update1(id: string, departmentRequest: DepartmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseDepartmentResponse> {
            return localVarFp.update1(id, departmentRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DepartmentManagementApi - object-oriented interface
 */
export class DepartmentManagementApi extends BaseAPI {
    /**
     * 
     * @param {DepartmentRequest} departmentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public create1(departmentRequest: DepartmentRequest, options?: RawAxiosRequestConfig) {
        return DepartmentManagementApiFp(this.configuration).create1(departmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public delete1(id: string, options?: RawAxiosRequestConfig) {
        return DepartmentManagementApiFp(this.configuration).delete1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SearchFilter} searchFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public filter2(searchFilter: SearchFilter, options?: RawAxiosRequestConfig) {
        return DepartmentManagementApiFp(this.configuration).filter2(searchFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} deptId 
     * @param {SearchFilter} searchFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public filterRoomsByDepartment(deptId: string, searchFilter: SearchFilter, options?: RawAxiosRequestConfig) {
        return DepartmentManagementApiFp(this.configuration).filterRoomsByDepartment(deptId, searchFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDepartmentById(id: string, options?: RawAxiosRequestConfig) {
        return DepartmentManagementApiFp(this.configuration).getDepartmentById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {DepartmentRequest} departmentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public update1(id: string, departmentRequest: DepartmentRequest, options?: RawAxiosRequestConfig) {
        return DepartmentManagementApiFp(this.configuration).update1(id, departmentRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DiagnosisControllerApi - axios parameter creator
 */
export const DiagnosisControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {DiagnosisRequest} diagnosisRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDiagnosis: async (id: string, diagnosisRequest: DiagnosisRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addDiagnosis', 'id', id)
            // verify required parameter 'diagnosisRequest' is not null or undefined
            assertParamExists('addDiagnosis', 'diagnosisRequest', diagnosisRequest)
            const localVarPath = `/api/examinations/{id}/diagnosis`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(diagnosisRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} diagnosisId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiagnosis: async (id: string, diagnosisId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDiagnosis', 'id', id)
            // verify required parameter 'diagnosisId' is not null or undefined
            assertParamExists('deleteDiagnosis', 'diagnosisId', diagnosisId)
            const localVarPath = `/api/examinations/{id}/diagnosis/{diagnosisId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"diagnosisId"}}`, encodeURIComponent(String(diagnosisId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filterDiagnosis: async (id: string, searchFilter: SearchFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('filterDiagnosis', 'id', id)
            // verify required parameter 'searchFilter' is not null or undefined
            assertParamExists('filterDiagnosis', 'searchFilter', searchFilter)
            const localVarPath = `/api/examinations/{id}/diagnosis/filter`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiagnosisList: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDiagnosisList', 'id', id)
            const localVarPath = `/api/examinations/{id}/diagnosis`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DiagnosisControllerApi - functional programming interface
 */
export const DiagnosisControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DiagnosisControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {DiagnosisRequest} diagnosisRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addDiagnosis(id: string, diagnosisRequest: DiagnosisRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseDiagnosisResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addDiagnosis(id, diagnosisRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DiagnosisControllerApi.addDiagnosis']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} diagnosisId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDiagnosis(id: string, diagnosisId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDiagnosis(id, diagnosisId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DiagnosisControllerApi.deleteDiagnosis']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filterDiagnosis(id: string, searchFilter: SearchFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePageDiagnosisResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filterDiagnosis(id, searchFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DiagnosisControllerApi.filterDiagnosis']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDiagnosisList(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseDiagnosisResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDiagnosisList(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DiagnosisControllerApi.getDiagnosisList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DiagnosisControllerApi - factory interface
 */
export const DiagnosisControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DiagnosisControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {DiagnosisRequest} diagnosisRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDiagnosis(id: string, diagnosisRequest: DiagnosisRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseDiagnosisResponse> {
            return localVarFp.addDiagnosis(id, diagnosisRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} diagnosisId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiagnosis(id: string, diagnosisId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.deleteDiagnosis(id, diagnosisId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filterDiagnosis(id: string, searchFilter: SearchFilter, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePageDiagnosisResponse> {
            return localVarFp.filterDiagnosis(id, searchFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiagnosisList(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseDiagnosisResponse> {
            return localVarFp.getDiagnosisList(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DiagnosisControllerApi - object-oriented interface
 */
export class DiagnosisControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {DiagnosisRequest} diagnosisRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addDiagnosis(id: string, diagnosisRequest: DiagnosisRequest, options?: RawAxiosRequestConfig) {
        return DiagnosisControllerApiFp(this.configuration).addDiagnosis(id, diagnosisRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} diagnosisId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteDiagnosis(id: string, diagnosisId: string, options?: RawAxiosRequestConfig) {
        return DiagnosisControllerApiFp(this.configuration).deleteDiagnosis(id, diagnosisId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {SearchFilter} searchFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public filterDiagnosis(id: string, searchFilter: SearchFilter, options?: RawAxiosRequestConfig) {
        return DiagnosisControllerApiFp(this.configuration).filterDiagnosis(id, searchFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDiagnosisList(id: string, options?: RawAxiosRequestConfig) {
        return DiagnosisControllerApiFp(this.configuration).getDiagnosisList(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DispenseRecordManagementApi - axios parameter creator
 */
export const DispenseRecordManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DispenseRecordRequest} dispenseRecordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create8: async (dispenseRecordRequest: DispenseRecordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dispenseRecordRequest' is not null or undefined
            assertParamExists('create8', 'dispenseRecordRequest', dispenseRecordRequest)
            const localVarPath = `/api/dispense-records`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dispenseRecordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} recordId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete8: async (recordId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recordId' is not null or undefined
            assertParamExists('delete8', 'recordId', recordId)
            const localVarPath = `/api/dispense-records/{recordId}`
                .replace(`{${"recordId"}}`, encodeURIComponent(String(recordId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filter8: async (searchFilter: SearchFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchFilter' is not null or undefined
            assertParamExists('filter8', 'searchFilter', searchFilter)
            const localVarPath = `/api/dispense-records/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} recordId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById4: async (recordId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recordId' is not null or undefined
            assertParamExists('getById4', 'recordId', recordId)
            const localVarPath = `/api/dispense-records/{recordId}`
                .replace(`{${"recordId"}}`, encodeURIComponent(String(recordId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersForStaffToday1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/dispense-records/staff/today`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} recordId 
         * @param {DispenseRecordRequest} dispenseRecordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update8: async (recordId: string, dispenseRecordRequest: DispenseRecordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recordId' is not null or undefined
            assertParamExists('update8', 'recordId', recordId)
            // verify required parameter 'dispenseRecordRequest' is not null or undefined
            assertParamExists('update8', 'dispenseRecordRequest', dispenseRecordRequest)
            const localVarPath = `/api/dispense-records/{recordId}`
                .replace(`{${"recordId"}}`, encodeURIComponent(String(recordId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dispenseRecordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DispenseRecordManagementApi - functional programming interface
 */
export const DispenseRecordManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DispenseRecordManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {DispenseRecordRequest} dispenseRecordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create8(dispenseRecordRequest: DispenseRecordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseDispenseRecordResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create8(dispenseRecordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DispenseRecordManagementApi.create8']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} recordId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete8(recordId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete8(recordId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DispenseRecordManagementApi.delete8']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filter8(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePageDispenseRecordResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filter8(searchFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DispenseRecordManagementApi.filter8']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} recordId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById4(recordId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseDispenseRecordResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById4(recordId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DispenseRecordManagementApi.getById4']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrdersForStaffToday1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseListDispenseRecordResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrdersForStaffToday1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DispenseRecordManagementApi.getOrdersForStaffToday1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} recordId 
         * @param {DispenseRecordRequest} dispenseRecordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update8(recordId: string, dispenseRecordRequest: DispenseRecordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseDispenseRecordResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update8(recordId, dispenseRecordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DispenseRecordManagementApi.update8']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DispenseRecordManagementApi - factory interface
 */
export const DispenseRecordManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DispenseRecordManagementApiFp(configuration)
    return {
        /**
         * 
         * @param {DispenseRecordRequest} dispenseRecordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create8(dispenseRecordRequest: DispenseRecordRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseDispenseRecordResponse> {
            return localVarFp.create8(dispenseRecordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} recordId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete8(recordId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.delete8(recordId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filter8(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePageDispenseRecordResponse> {
            return localVarFp.filter8(searchFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} recordId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById4(recordId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseDispenseRecordResponse> {
            return localVarFp.getById4(recordId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersForStaffToday1(options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseListDispenseRecordResponse> {
            return localVarFp.getOrdersForStaffToday1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} recordId 
         * @param {DispenseRecordRequest} dispenseRecordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update8(recordId: string, dispenseRecordRequest: DispenseRecordRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseDispenseRecordResponse> {
            return localVarFp.update8(recordId, dispenseRecordRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DispenseRecordManagementApi - object-oriented interface
 */
export class DispenseRecordManagementApi extends BaseAPI {
    /**
     * 
     * @param {DispenseRecordRequest} dispenseRecordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public create8(dispenseRecordRequest: DispenseRecordRequest, options?: RawAxiosRequestConfig) {
        return DispenseRecordManagementApiFp(this.configuration).create8(dispenseRecordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} recordId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public delete8(recordId: string, options?: RawAxiosRequestConfig) {
        return DispenseRecordManagementApiFp(this.configuration).delete8(recordId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SearchFilter} searchFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public filter8(searchFilter: SearchFilter, options?: RawAxiosRequestConfig) {
        return DispenseRecordManagementApiFp(this.configuration).filter8(searchFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} recordId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getById4(recordId: string, options?: RawAxiosRequestConfig) {
        return DispenseRecordManagementApiFp(this.configuration).getById4(recordId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getOrdersForStaffToday1(options?: RawAxiosRequestConfig) {
        return DispenseRecordManagementApiFp(this.configuration).getOrdersForStaffToday1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} recordId 
     * @param {DispenseRecordRequest} dispenseRecordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public update8(recordId: string, dispenseRecordRequest: DispenseRecordRequest, options?: RawAxiosRequestConfig) {
        return DispenseRecordManagementApiFp(this.configuration).update8(recordId, dispenseRecordRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExaminationControllerApi - axios parameter creator
 */
export const ExaminationControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ExaminationRequest} examinationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExamination: async (examinationRequest: ExaminationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'examinationRequest' is not null or undefined
            assertParamExists('createExamination', 'examinationRequest', examinationRequest)
            const localVarPath = `/api/examinations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(examinationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {CreateLabOrderRequest} createLabOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLabOrder: async (id: string, createLabOrderRequest: CreateLabOrderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createLabOrder', 'id', id)
            // verify required parameter 'createLabOrderRequest' is not null or undefined
            assertParamExists('createLabOrder', 'createLabOrderRequest', createLabOrderRequest)
            const localVarPath = `/api/examinations/{id}/lab/orders`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createLabOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} examId 
         * @param {CreateServiceOrderRequest} createServiceOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrders: async (examId: string, createServiceOrderRequest: CreateServiceOrderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'examId' is not null or undefined
            assertParamExists('createOrders', 'examId', examId)
            // verify required parameter 'createServiceOrderRequest' is not null or undefined
            assertParamExists('createOrders', 'createServiceOrderRequest', createServiceOrderRequest)
            const localVarPath = `/api/examinations/{examId}/services/orders`
                .replace(`{${"examId"}}`, encodeURIComponent(String(examId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createServiceOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {PrescriptionRequest} prescriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPrescription: async (id: string, prescriptionRequest: PrescriptionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPrescription', 'id', id)
            // verify required parameter 'prescriptionRequest' is not null or undefined
            assertParamExists('createPrescription', 'prescriptionRequest', prescriptionRequest)
            const localVarPath = `/api/examinations/{id}/prescription`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prescriptionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {ServiceOrderRequest} serviceOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServiceOrder: async (id: string, serviceOrderRequest: ServiceOrderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createServiceOrder', 'id', id)
            // verify required parameter 'serviceOrderRequest' is not null or undefined
            assertParamExists('createServiceOrder', 'serviceOrderRequest', serviceOrderRequest)
            const localVarPath = `/api/examinations/{id}/services`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} prescriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePrescriptionItem1: async (prescriptionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prescriptionId' is not null or undefined
            assertParamExists('deletePrescriptionItem1', 'prescriptionId', prescriptionId)
            const localVarPath = `/api/examinations/prescription/{prescriptionId}`
                .replace(`{${"prescriptionId"}}`, encodeURIComponent(String(prescriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceOrderItem: async (id: string, itemId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteServiceOrderItem', 'id', id)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('deleteServiceOrderItem', 'itemId', itemId)
            const localVarPath = `/api/examinations/{id}/services/item/{itemId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filterLabOrders: async (id: string, searchFilter: SearchFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('filterLabOrders', 'id', id)
            // verify required parameter 'searchFilter' is not null or undefined
            assertParamExists('filterLabOrders', 'searchFilter', searchFilter)
            const localVarPath = `/api/examinations/{id}/lab/orders/filter`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} examId 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filterServiceOrders: async (examId: string, searchFilter: SearchFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'examId' is not null or undefined
            assertParamExists('filterServiceOrders', 'examId', examId)
            // verify required parameter 'searchFilter' is not null or undefined
            assertParamExists('filterServiceOrders', 'searchFilter', searchFilter)
            const localVarPath = `/api/examinations/{examId}/services/filter`
                .replace(`{${"examId"}}`, encodeURIComponent(String(examId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExaminationDetail: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getExaminationDetail', 'id', id)
            const localVarPath = `/api/examinations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExaminations: async (searchFilter: SearchFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchFilter' is not null or undefined
            assertParamExists('getExaminations', 'searchFilter', searchFilter)
            const localVarPath = `/api/examinations/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrescription: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPrescription', 'id', id)
            const localVarPath = `/api/examinations/{id}/prescription`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceOrders: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getServiceOrders', 'id', id)
            const localVarPath = `/api/examinations/{id}/services`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} prescriptionId 
         * @param {PrescriptionRequest} prescriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveOrUpdatePrescription: async (id: string, prescriptionId: string, prescriptionRequest: PrescriptionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('saveOrUpdatePrescription', 'id', id)
            // verify required parameter 'prescriptionId' is not null or undefined
            assertParamExists('saveOrUpdatePrescription', 'prescriptionId', prescriptionId)
            // verify required parameter 'prescriptionRequest' is not null or undefined
            assertParamExists('saveOrUpdatePrescription', 'prescriptionRequest', prescriptionRequest)
            const localVarPath = `/api/examinations/{id}/prescription/{prescriptionId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"prescriptionId"}}`, encodeURIComponent(String(prescriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prescriptionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} serviceOrderId 
         * @param {ServiceOrderRequest} serviceOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveOrUpdateServiceOrders: async (id: string, serviceOrderId: string, serviceOrderRequest: ServiceOrderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('saveOrUpdateServiceOrders', 'id', id)
            // verify required parameter 'serviceOrderId' is not null or undefined
            assertParamExists('saveOrUpdateServiceOrders', 'serviceOrderId', serviceOrderId)
            // verify required parameter 'serviceOrderRequest' is not null or undefined
            assertParamExists('saveOrUpdateServiceOrders', 'serviceOrderRequest', serviceOrderRequest)
            const localVarPath = `/api/examinations/{id}/services/{serviceOrderId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"serviceOrderId"}}`, encodeURIComponent(String(serviceOrderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {ExaminationRequest} examinationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExamination: async (id: string, examinationRequest: ExaminationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateExamination', 'id', id)
            // verify required parameter 'examinationRequest' is not null or undefined
            assertParamExists('updateExamination', 'examinationRequest', examinationRequest)
            const localVarPath = `/api/examinations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(examinationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExaminationControllerApi - functional programming interface
 */
export const ExaminationControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExaminationControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ExaminationRequest} examinationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createExamination(examinationRequest: ExaminationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseExaminationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExamination(examinationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExaminationControllerApi.createExamination']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {CreateLabOrderRequest} createLabOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLabOrder(id: string, createLabOrderRequest: CreateLabOrderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseListLabOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLabOrder(id, createLabOrderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExaminationControllerApi.createLabOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} examId 
         * @param {CreateServiceOrderRequest} createServiceOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrders(examId: string, createServiceOrderRequest: CreateServiceOrderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseListServiceOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrders(examId, createServiceOrderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExaminationControllerApi.createOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {PrescriptionRequest} prescriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPrescription(id: string, prescriptionRequest: PrescriptionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePrescriptionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPrescription(id, prescriptionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExaminationControllerApi.createPrescription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {ServiceOrderRequest} serviceOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createServiceOrder(id: string, serviceOrderRequest: ServiceOrderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseServiceOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createServiceOrder(id, serviceOrderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExaminationControllerApi.createServiceOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} prescriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePrescriptionItem1(prescriptionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePrescriptionItem1(prescriptionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExaminationControllerApi.deletePrescriptionItem1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteServiceOrderItem(id: string, itemId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteServiceOrderItem(id, itemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExaminationControllerApi.deleteServiceOrderItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filterLabOrders(id: string, searchFilter: SearchFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePageLabOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filterLabOrders(id, searchFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExaminationControllerApi.filterLabOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} examId 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filterServiceOrders(examId: string, searchFilter: SearchFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePageServiceOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filterServiceOrders(examId, searchFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExaminationControllerApi.filterServiceOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExaminationDetail(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseExaminationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExaminationDetail(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExaminationControllerApi.getExaminationDetail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExaminations(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePageExaminationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExaminations(searchFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExaminationControllerApi.getExaminations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPrescription(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePrescriptionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPrescription(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExaminationControllerApi.getPrescription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceOrders(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseServiceOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceOrders(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExaminationControllerApi.getServiceOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} prescriptionId 
         * @param {PrescriptionRequest} prescriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveOrUpdatePrescription(id: string, prescriptionId: string, prescriptionRequest: PrescriptionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePrescriptionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveOrUpdatePrescription(id, prescriptionId, prescriptionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExaminationControllerApi.saveOrUpdatePrescription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} serviceOrderId 
         * @param {ServiceOrderRequest} serviceOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveOrUpdateServiceOrders(id: string, serviceOrderId: string, serviceOrderRequest: ServiceOrderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseServiceOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveOrUpdateServiceOrders(id, serviceOrderId, serviceOrderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExaminationControllerApi.saveOrUpdateServiceOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {ExaminationRequest} examinationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateExamination(id: string, examinationRequest: ExaminationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseExaminationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateExamination(id, examinationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExaminationControllerApi.updateExamination']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ExaminationControllerApi - factory interface
 */
export const ExaminationControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExaminationControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {ExaminationRequest} examinationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExamination(examinationRequest: ExaminationRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseExaminationResponse> {
            return localVarFp.createExamination(examinationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {CreateLabOrderRequest} createLabOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLabOrder(id: string, createLabOrderRequest: CreateLabOrderRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseListLabOrderResponse> {
            return localVarFp.createLabOrder(id, createLabOrderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} examId 
         * @param {CreateServiceOrderRequest} createServiceOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrders(examId: string, createServiceOrderRequest: CreateServiceOrderRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseListServiceOrderResponse> {
            return localVarFp.createOrders(examId, createServiceOrderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {PrescriptionRequest} prescriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPrescription(id: string, prescriptionRequest: PrescriptionRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePrescriptionResponse> {
            return localVarFp.createPrescription(id, prescriptionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {ServiceOrderRequest} serviceOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServiceOrder(id: string, serviceOrderRequest: ServiceOrderRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseServiceOrderResponse> {
            return localVarFp.createServiceOrder(id, serviceOrderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} prescriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePrescriptionItem1(prescriptionId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.deletePrescriptionItem1(prescriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceOrderItem(id: string, itemId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.deleteServiceOrderItem(id, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filterLabOrders(id: string, searchFilter: SearchFilter, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePageLabOrderResponse> {
            return localVarFp.filterLabOrders(id, searchFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} examId 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filterServiceOrders(examId: string, searchFilter: SearchFilter, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePageServiceOrderResponse> {
            return localVarFp.filterServiceOrders(examId, searchFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExaminationDetail(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseExaminationResponse> {
            return localVarFp.getExaminationDetail(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExaminations(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePageExaminationResponse> {
            return localVarFp.getExaminations(searchFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrescription(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePrescriptionResponse> {
            return localVarFp.getPrescription(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceOrders(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseServiceOrderResponse> {
            return localVarFp.getServiceOrders(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} prescriptionId 
         * @param {PrescriptionRequest} prescriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveOrUpdatePrescription(id: string, prescriptionId: string, prescriptionRequest: PrescriptionRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePrescriptionResponse> {
            return localVarFp.saveOrUpdatePrescription(id, prescriptionId, prescriptionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} serviceOrderId 
         * @param {ServiceOrderRequest} serviceOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveOrUpdateServiceOrders(id: string, serviceOrderId: string, serviceOrderRequest: ServiceOrderRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseServiceOrderResponse> {
            return localVarFp.saveOrUpdateServiceOrders(id, serviceOrderId, serviceOrderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {ExaminationRequest} examinationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExamination(id: string, examinationRequest: ExaminationRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseExaminationResponse> {
            return localVarFp.updateExamination(id, examinationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExaminationControllerApi - object-oriented interface
 */
export class ExaminationControllerApi extends BaseAPI {
    /**
     * 
     * @param {ExaminationRequest} examinationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createExamination(examinationRequest: ExaminationRequest, options?: RawAxiosRequestConfig) {
        return ExaminationControllerApiFp(this.configuration).createExamination(examinationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {CreateLabOrderRequest} createLabOrderRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createLabOrder(id: string, createLabOrderRequest: CreateLabOrderRequest, options?: RawAxiosRequestConfig) {
        return ExaminationControllerApiFp(this.configuration).createLabOrder(id, createLabOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} examId 
     * @param {CreateServiceOrderRequest} createServiceOrderRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createOrders(examId: string, createServiceOrderRequest: CreateServiceOrderRequest, options?: RawAxiosRequestConfig) {
        return ExaminationControllerApiFp(this.configuration).createOrders(examId, createServiceOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {PrescriptionRequest} prescriptionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createPrescription(id: string, prescriptionRequest: PrescriptionRequest, options?: RawAxiosRequestConfig) {
        return ExaminationControllerApiFp(this.configuration).createPrescription(id, prescriptionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {ServiceOrderRequest} serviceOrderRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createServiceOrder(id: string, serviceOrderRequest: ServiceOrderRequest, options?: RawAxiosRequestConfig) {
        return ExaminationControllerApiFp(this.configuration).createServiceOrder(id, serviceOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} prescriptionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deletePrescriptionItem1(prescriptionId: string, options?: RawAxiosRequestConfig) {
        return ExaminationControllerApiFp(this.configuration).deletePrescriptionItem1(prescriptionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} itemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteServiceOrderItem(id: string, itemId: string, options?: RawAxiosRequestConfig) {
        return ExaminationControllerApiFp(this.configuration).deleteServiceOrderItem(id, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {SearchFilter} searchFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public filterLabOrders(id: string, searchFilter: SearchFilter, options?: RawAxiosRequestConfig) {
        return ExaminationControllerApiFp(this.configuration).filterLabOrders(id, searchFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} examId 
     * @param {SearchFilter} searchFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public filterServiceOrders(examId: string, searchFilter: SearchFilter, options?: RawAxiosRequestConfig) {
        return ExaminationControllerApiFp(this.configuration).filterServiceOrders(examId, searchFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getExaminationDetail(id: string, options?: RawAxiosRequestConfig) {
        return ExaminationControllerApiFp(this.configuration).getExaminationDetail(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SearchFilter} searchFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getExaminations(searchFilter: SearchFilter, options?: RawAxiosRequestConfig) {
        return ExaminationControllerApiFp(this.configuration).getExaminations(searchFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPrescription(id: string, options?: RawAxiosRequestConfig) {
        return ExaminationControllerApiFp(this.configuration).getPrescription(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getServiceOrders(id: string, options?: RawAxiosRequestConfig) {
        return ExaminationControllerApiFp(this.configuration).getServiceOrders(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} prescriptionId 
     * @param {PrescriptionRequest} prescriptionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public saveOrUpdatePrescription(id: string, prescriptionId: string, prescriptionRequest: PrescriptionRequest, options?: RawAxiosRequestConfig) {
        return ExaminationControllerApiFp(this.configuration).saveOrUpdatePrescription(id, prescriptionId, prescriptionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} serviceOrderId 
     * @param {ServiceOrderRequest} serviceOrderRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public saveOrUpdateServiceOrders(id: string, serviceOrderId: string, serviceOrderRequest: ServiceOrderRequest, options?: RawAxiosRequestConfig) {
        return ExaminationControllerApiFp(this.configuration).saveOrUpdateServiceOrders(id, serviceOrderId, serviceOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {ExaminationRequest} examinationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateExamination(id: string, examinationRequest: ExaminationRequest, options?: RawAxiosRequestConfig) {
        return ExaminationControllerApiFp(this.configuration).updateExamination(id, examinationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FileManagementApi - axios parameter creator
 */
export const FileManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} entityType 
         * @param {string} entityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFiles: async (entityType: string, entityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entityType' is not null or undefined
            assertParamExists('getFiles', 'entityType', entityType)
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('getFiles', 'entityId', entityId)
            const localVarPath = `/api/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (entityType !== undefined) {
                localVarQueryParameter['entityType'] = entityType;
            }

            if (entityId !== undefined) {
                localVarQueryParameter['entityId'] = entityId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewFile: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewFile', 'id', id)
            const localVarPath = `/api/files/view/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FileManagementApi - functional programming interface
 */
export const FileManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FileManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} entityType 
         * @param {string} entityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFiles(entityType: string, entityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseListFileAttachmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFiles(entityType, entityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileManagementApi.getFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewFile(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewFile(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileManagementApi.viewFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FileManagementApi - factory interface
 */
export const FileManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FileManagementApiFp(configuration)
    return {
        /**
         * 
         * @param {string} entityType 
         * @param {string} entityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFiles(entityType: string, entityId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseListFileAttachmentResponse> {
            return localVarFp.getFiles(entityType, entityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewFile(id: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.viewFile(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FileManagementApi - object-oriented interface
 */
export class FileManagementApi extends BaseAPI {
    /**
     * 
     * @param {string} entityType 
     * @param {string} entityId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFiles(entityType: string, entityId: string, options?: RawAxiosRequestConfig) {
        return FileManagementApiFp(this.configuration).getFiles(entityType, entityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public viewFile(id: string, options?: RawAxiosRequestConfig) {
        return FileManagementApiFp(this.configuration).viewFile(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FileUploadApi - axios parameter creator
 */
export const FileUploadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} entityType 
         * @param {string} entityId 
         * @param {Array<File>} files 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMultiple: async (entityType: string, entityId: string, files: Array<File>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entityType' is not null or undefined
            assertParamExists('uploadMultiple', 'entityType', entityType)
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('uploadMultiple', 'entityId', entityId)
            // verify required parameter 'files' is not null or undefined
            assertParamExists('uploadMultiple', 'files', files)
            const localVarPath = `/api/files/upload-multiple`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (entityType !== undefined) {
                localVarQueryParameter['entityType'] = entityType;
            }

            if (entityId !== undefined) {
                localVarQueryParameter['entityId'] = entityId;
            }

            if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} entityType 
         * @param {string} entityId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadSingle: async (entityType: string, entityId: string, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entityType' is not null or undefined
            assertParamExists('uploadSingle', 'entityType', entityType)
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('uploadSingle', 'entityId', entityId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadSingle', 'file', file)
            const localVarPath = `/api/files/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (entityType !== undefined) {
                localVarQueryParameter['entityType'] = entityType;
            }

            if (entityId !== undefined) {
                localVarQueryParameter['entityId'] = entityId;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FileUploadApi - functional programming interface
 */
export const FileUploadApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FileUploadApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} entityType 
         * @param {string} entityId 
         * @param {Array<File>} files 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadMultiple(entityType: string, entityId: string, files: Array<File>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseListString>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadMultiple(entityType, entityId, files, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileUploadApi.uploadMultiple']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} entityType 
         * @param {string} entityId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadSingle(entityType: string, entityId: string, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseString>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadSingle(entityType, entityId, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileUploadApi.uploadSingle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FileUploadApi - factory interface
 */
export const FileUploadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FileUploadApiFp(configuration)
    return {
        /**
         * 
         * @param {string} entityType 
         * @param {string} entityId 
         * @param {Array<File>} files 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMultiple(entityType: string, entityId: string, files: Array<File>, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseListString> {
            return localVarFp.uploadMultiple(entityType, entityId, files, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} entityType 
         * @param {string} entityId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadSingle(entityType: string, entityId: string, file: File, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseString> {
            return localVarFp.uploadSingle(entityType, entityId, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FileUploadApi - object-oriented interface
 */
export class FileUploadApi extends BaseAPI {
    /**
     * 
     * @param {string} entityType 
     * @param {string} entityId 
     * @param {Array<File>} files 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploadMultiple(entityType: string, entityId: string, files: Array<File>, options?: RawAxiosRequestConfig) {
        return FileUploadApiFp(this.configuration).uploadMultiple(entityType, entityId, files, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} entityType 
     * @param {string} entityId 
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploadSingle(entityType: string, entityId: string, file: File, options?: RawAxiosRequestConfig) {
        return FileUploadApiFp(this.configuration).uploadSingle(entityType, entityId, file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ICDCodeManagementApi - axios parameter creator
 */
export const ICDCodeManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {IcdCodeRequest} icdCodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIcdCode: async (icdCodeRequest: IcdCodeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'icdCodeRequest' is not null or undefined
            assertParamExists('createIcdCode', 'icdCodeRequest', icdCodeRequest)
            const localVarPath = `/api/common/icd-codes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(icdCodeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIcdCode: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteIcdCode', 'id', id)
            const localVarPath = `/api/common/icd-codes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filter9: async (searchFilter: SearchFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchFilter' is not null or undefined
            assertParamExists('filter9', 'searchFilter', searchFilter)
            const localVarPath = `/api/common/icd-codes/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIcdCodeById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIcdCodeById', 'id', id)
            const localVarPath = `/api/common/icd-codes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {IcdCodeRequest} icdCodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIcdCode: async (id: string, icdCodeRequest: IcdCodeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateIcdCode', 'id', id)
            // verify required parameter 'icdCodeRequest' is not null or undefined
            assertParamExists('updateIcdCode', 'icdCodeRequest', icdCodeRequest)
            const localVarPath = `/api/common/icd-codes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(icdCodeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ICDCodeManagementApi - functional programming interface
 */
export const ICDCodeManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ICDCodeManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {IcdCodeRequest} icdCodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createIcdCode(icdCodeRequest: IcdCodeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseIcdCodeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createIcdCode(icdCodeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ICDCodeManagementApi.createIcdCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteIcdCode(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteIcdCode(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ICDCodeManagementApi.deleteIcdCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filter9(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePageIcdCodeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filter9(searchFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ICDCodeManagementApi.filter9']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIcdCodeById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseIcdCodeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIcdCodeById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ICDCodeManagementApi.getIcdCodeById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {IcdCodeRequest} icdCodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateIcdCode(id: string, icdCodeRequest: IcdCodeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseIcdCodeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateIcdCode(id, icdCodeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ICDCodeManagementApi.updateIcdCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ICDCodeManagementApi - factory interface
 */
export const ICDCodeManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ICDCodeManagementApiFp(configuration)
    return {
        /**
         * 
         * @param {IcdCodeRequest} icdCodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIcdCode(icdCodeRequest: IcdCodeRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseIcdCodeResponse> {
            return localVarFp.createIcdCode(icdCodeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIcdCode(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.deleteIcdCode(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filter9(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePageIcdCodeResponse> {
            return localVarFp.filter9(searchFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIcdCodeById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseIcdCodeResponse> {
            return localVarFp.getIcdCodeById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {IcdCodeRequest} icdCodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIcdCode(id: string, icdCodeRequest: IcdCodeRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseIcdCodeResponse> {
            return localVarFp.updateIcdCode(id, icdCodeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ICDCodeManagementApi - object-oriented interface
 */
export class ICDCodeManagementApi extends BaseAPI {
    /**
     * 
     * @param {IcdCodeRequest} icdCodeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createIcdCode(icdCodeRequest: IcdCodeRequest, options?: RawAxiosRequestConfig) {
        return ICDCodeManagementApiFp(this.configuration).createIcdCode(icdCodeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteIcdCode(id: string, options?: RawAxiosRequestConfig) {
        return ICDCodeManagementApiFp(this.configuration).deleteIcdCode(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SearchFilter} searchFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public filter9(searchFilter: SearchFilter, options?: RawAxiosRequestConfig) {
        return ICDCodeManagementApiFp(this.configuration).filter9(searchFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getIcdCodeById(id: string, options?: RawAxiosRequestConfig) {
        return ICDCodeManagementApiFp(this.configuration).getIcdCodeById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {IcdCodeRequest} icdCodeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateIcdCode(id: string, icdCodeRequest: IcdCodeRequest, options?: RawAxiosRequestConfig) {
        return ICDCodeManagementApiFp(this.configuration).updateIcdCode(id, icdCodeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InvoiceManagementApi - axios parameter creator
 */
export const InvoiceManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {InvoiceRequest} invoiceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create6: async (invoiceRequest: InvoiceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceRequest' is not null or undefined
            assertParamExists('create6', 'invoiceRequest', invoiceRequest)
            const localVarPath = `/api/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(invoiceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete6: async (invoiceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('delete6', 'invoiceId', invoiceId)
            const localVarPath = `/api/invoices/{invoiceId}`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filter7: async (searchFilter: SearchFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchFilter' is not null or undefined
            assertParamExists('filter7', 'searchFilter', searchFilter)
            const localVarPath = `/api/invoices/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById3: async (invoiceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('getById3', 'invoiceId', invoiceId)
            const localVarPath = `/api/invoices/{invoiceId}`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersForStaffToday: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/invoices/staff/today`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} invoiceId 
         * @param {InvoiceRequest} invoiceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update6: async (invoiceId: string, invoiceRequest: InvoiceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('update6', 'invoiceId', invoiceId)
            // verify required parameter 'invoiceRequest' is not null or undefined
            assertParamExists('update6', 'invoiceRequest', invoiceRequest)
            const localVarPath = `/api/invoices/{invoiceId}`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(invoiceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoiceManagementApi - functional programming interface
 */
export const InvoiceManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvoiceManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {InvoiceRequest} invoiceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create6(invoiceRequest: InvoiceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseInvoiceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create6(invoiceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoiceManagementApi.create6']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete6(invoiceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete6(invoiceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoiceManagementApi.delete6']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filter7(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePageInvoiceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filter7(searchFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoiceManagementApi.filter7']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById3(invoiceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseInvoiceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById3(invoiceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoiceManagementApi.getById3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrdersForStaffToday(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseListInvoiceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrdersForStaffToday(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoiceManagementApi.getOrdersForStaffToday']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} invoiceId 
         * @param {InvoiceRequest} invoiceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update6(invoiceId: string, invoiceRequest: InvoiceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseInvoiceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update6(invoiceId, invoiceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoiceManagementApi.update6']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InvoiceManagementApi - factory interface
 */
export const InvoiceManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvoiceManagementApiFp(configuration)
    return {
        /**
         * 
         * @param {InvoiceRequest} invoiceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create6(invoiceRequest: InvoiceRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseInvoiceResponse> {
            return localVarFp.create6(invoiceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete6(invoiceId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.delete6(invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filter7(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePageInvoiceResponse> {
            return localVarFp.filter7(searchFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById3(invoiceId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseInvoiceResponse> {
            return localVarFp.getById3(invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersForStaffToday(options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseListInvoiceResponse> {
            return localVarFp.getOrdersForStaffToday(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} invoiceId 
         * @param {InvoiceRequest} invoiceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update6(invoiceId: string, invoiceRequest: InvoiceRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseInvoiceResponse> {
            return localVarFp.update6(invoiceId, invoiceRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvoiceManagementApi - object-oriented interface
 */
export class InvoiceManagementApi extends BaseAPI {
    /**
     * 
     * @param {InvoiceRequest} invoiceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public create6(invoiceRequest: InvoiceRequest, options?: RawAxiosRequestConfig) {
        return InvoiceManagementApiFp(this.configuration).create6(invoiceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} invoiceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public delete6(invoiceId: string, options?: RawAxiosRequestConfig) {
        return InvoiceManagementApiFp(this.configuration).delete6(invoiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SearchFilter} searchFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public filter7(searchFilter: SearchFilter, options?: RawAxiosRequestConfig) {
        return InvoiceManagementApiFp(this.configuration).filter7(searchFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} invoiceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getById3(invoiceId: string, options?: RawAxiosRequestConfig) {
        return InvoiceManagementApiFp(this.configuration).getById3(invoiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getOrdersForStaffToday(options?: RawAxiosRequestConfig) {
        return InvoiceManagementApiFp(this.configuration).getOrdersForStaffToday(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} invoiceId 
     * @param {InvoiceRequest} invoiceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public update6(invoiceId: string, invoiceRequest: InvoiceRequest, options?: RawAxiosRequestConfig) {
        return InvoiceManagementApiFp(this.configuration).update6(invoiceId, invoiceRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LabOrderManagementApi - axios parameter creator
 */
export const LabOrderManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} orderId 
         * @param {LabTestResultRequest} labTestResultRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrderItem: async (orderId: string, labTestResultRequest: LabTestResultRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('addOrderItem', 'orderId', orderId)
            // verify required parameter 'labTestResultRequest' is not null or undefined
            assertParamExists('addOrderItem', 'labTestResultRequest', labTestResultRequest)
            const localVarPath = `/api/lab-orders/{orderId}/results`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(labTestResultRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LabOrderRequest} labOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create5: async (labOrderRequest: LabOrderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'labOrderRequest' is not null or undefined
            assertParamExists('create5', 'labOrderRequest', labOrderRequest)
            const localVarPath = `/api/lab-orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(labOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete5: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('delete5', 'orderId', orderId)
            const localVarPath = `/api/lab-orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orderId 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrderItem: async (orderId: string, itemId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('deleteOrderItem', 'orderId', orderId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('deleteOrderItem', 'itemId', itemId)
            const localVarPath = `/api/lab-orders/{orderId}/order-items/{itemId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filter6: async (searchFilter: SearchFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchFilter' is not null or undefined
            assertParamExists('filter6', 'searchFilter', searchFilter)
            const localVarPath = `/api/lab-orders/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orderId 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filterOrderItems: async (orderId: string, searchFilter: SearchFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('filterOrderItems', 'orderId', orderId)
            // verify required parameter 'searchFilter' is not null or undefined
            assertParamExists('filterOrderItems', 'searchFilter', searchFilter)
            const localVarPath = `/api/lab-orders/{orderId}/results/filter`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById2: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('getById2', 'orderId', orderId)
            const localVarPath = `/api/lab-orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLabOrdersForStaffToday: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/lab-orders/staff/today`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orderId 
         * @param {LabOrderRequest} labOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update5: async (orderId: string, labOrderRequest: LabOrderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('update5', 'orderId', orderId)
            // verify required parameter 'labOrderRequest' is not null or undefined
            assertParamExists('update5', 'labOrderRequest', labOrderRequest)
            const localVarPath = `/api/lab-orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(labOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {LabTestResultRequest} labTestResultRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrderItem: async (itemId: string, labTestResultRequest: LabTestResultRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('updateOrderItem', 'itemId', itemId)
            // verify required parameter 'labTestResultRequest' is not null or undefined
            assertParamExists('updateOrderItem', 'labTestResultRequest', labTestResultRequest)
            const localVarPath = `/api/lab-orders/results/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(labTestResultRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyOrderItem: async (itemId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('verifyOrderItem', 'itemId', itemId)
            const localVarPath = `/api/lab-orders/result/{itemId}/verify`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LabOrderManagementApi - functional programming interface
 */
export const LabOrderManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LabOrderManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} orderId 
         * @param {LabTestResultRequest} labTestResultRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrderItem(orderId: string, labTestResultRequest: LabTestResultRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseLabTestResultResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrderItem(orderId, labTestResultRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LabOrderManagementApi.addOrderItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {LabOrderRequest} labOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create5(labOrderRequest: LabOrderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseLabOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create5(labOrderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LabOrderManagementApi.create5']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete5(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete5(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LabOrderManagementApi.delete5']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orderId 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrderItem(orderId: string, itemId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrderItem(orderId, itemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LabOrderManagementApi.deleteOrderItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filter6(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePageLabOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filter6(searchFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LabOrderManagementApi.filter6']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orderId 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filterOrderItems(orderId: string, searchFilter: SearchFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePageLabTestResultResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filterOrderItems(orderId, searchFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LabOrderManagementApi.filterOrderItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById2(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseLabOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById2(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LabOrderManagementApi.getById2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLabOrdersForStaffToday(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseListLabOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLabOrdersForStaffToday(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LabOrderManagementApi.getLabOrdersForStaffToday']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orderId 
         * @param {LabOrderRequest} labOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update5(orderId: string, labOrderRequest: LabOrderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseLabOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update5(orderId, labOrderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LabOrderManagementApi.update5']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} itemId 
         * @param {LabTestResultRequest} labTestResultRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrderItem(itemId: string, labTestResultRequest: LabTestResultRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseLabTestResultResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrderItem(itemId, labTestResultRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LabOrderManagementApi.updateOrderItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyOrderItem(itemId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyOrderItem(itemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LabOrderManagementApi.verifyOrderItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LabOrderManagementApi - factory interface
 */
export const LabOrderManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LabOrderManagementApiFp(configuration)
    return {
        /**
         * 
         * @param {string} orderId 
         * @param {LabTestResultRequest} labTestResultRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrderItem(orderId: string, labTestResultRequest: LabTestResultRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseLabTestResultResponse> {
            return localVarFp.addOrderItem(orderId, labTestResultRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LabOrderRequest} labOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create5(labOrderRequest: LabOrderRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseLabOrderResponse> {
            return localVarFp.create5(labOrderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete5(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.delete5(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orderId 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrderItem(orderId: string, itemId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.deleteOrderItem(orderId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filter6(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePageLabOrderResponse> {
            return localVarFp.filter6(searchFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orderId 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filterOrderItems(orderId: string, searchFilter: SearchFilter, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePageLabTestResultResponse> {
            return localVarFp.filterOrderItems(orderId, searchFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById2(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseLabOrderResponse> {
            return localVarFp.getById2(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLabOrdersForStaffToday(options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseListLabOrderResponse> {
            return localVarFp.getLabOrdersForStaffToday(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orderId 
         * @param {LabOrderRequest} labOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update5(orderId: string, labOrderRequest: LabOrderRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseLabOrderResponse> {
            return localVarFp.update5(orderId, labOrderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {LabTestResultRequest} labTestResultRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrderItem(itemId: string, labTestResultRequest: LabTestResultRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseLabTestResultResponse> {
            return localVarFp.updateOrderItem(itemId, labTestResultRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyOrderItem(itemId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.verifyOrderItem(itemId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LabOrderManagementApi - object-oriented interface
 */
export class LabOrderManagementApi extends BaseAPI {
    /**
     * 
     * @param {string} orderId 
     * @param {LabTestResultRequest} labTestResultRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addOrderItem(orderId: string, labTestResultRequest: LabTestResultRequest, options?: RawAxiosRequestConfig) {
        return LabOrderManagementApiFp(this.configuration).addOrderItem(orderId, labTestResultRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LabOrderRequest} labOrderRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public create5(labOrderRequest: LabOrderRequest, options?: RawAxiosRequestConfig) {
        return LabOrderManagementApiFp(this.configuration).create5(labOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public delete5(orderId: string, options?: RawAxiosRequestConfig) {
        return LabOrderManagementApiFp(this.configuration).delete5(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orderId 
     * @param {string} itemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteOrderItem(orderId: string, itemId: string, options?: RawAxiosRequestConfig) {
        return LabOrderManagementApiFp(this.configuration).deleteOrderItem(orderId, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SearchFilter} searchFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public filter6(searchFilter: SearchFilter, options?: RawAxiosRequestConfig) {
        return LabOrderManagementApiFp(this.configuration).filter6(searchFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orderId 
     * @param {SearchFilter} searchFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public filterOrderItems(orderId: string, searchFilter: SearchFilter, options?: RawAxiosRequestConfig) {
        return LabOrderManagementApiFp(this.configuration).filterOrderItems(orderId, searchFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getById2(orderId: string, options?: RawAxiosRequestConfig) {
        return LabOrderManagementApiFp(this.configuration).getById2(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getLabOrdersForStaffToday(options?: RawAxiosRequestConfig) {
        return LabOrderManagementApiFp(this.configuration).getLabOrdersForStaffToday(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orderId 
     * @param {LabOrderRequest} labOrderRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public update5(orderId: string, labOrderRequest: LabOrderRequest, options?: RawAxiosRequestConfig) {
        return LabOrderManagementApiFp(this.configuration).update5(orderId, labOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} itemId 
     * @param {LabTestResultRequest} labTestResultRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateOrderItem(itemId: string, labTestResultRequest: LabTestResultRequest, options?: RawAxiosRequestConfig) {
        return LabOrderManagementApiFp(this.configuration).updateOrderItem(itemId, labTestResultRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} itemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public verifyOrderItem(itemId: string, options?: RawAxiosRequestConfig) {
        return LabOrderManagementApiFp(this.configuration).verifyOrderItem(itemId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LabTestManagementApi - axios parameter creator
 */
export const LabTestManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {LabTestRequest} labTestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create4: async (labTestRequest: LabTestRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'labTestRequest' is not null or undefined
            assertParamExists('create4', 'labTestRequest', labTestRequest)
            const localVarPath = `/api/lab-tests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(labTestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete4: async (testId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('delete4', 'testId', testId)
            const localVarPath = `/api/lab-tests/{testId}`
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filter5: async (searchFilter: SearchFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchFilter' is not null or undefined
            assertParamExists('filter5', 'searchFilter', searchFilter)
            const localVarPath = `/api/lab-tests/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById1: async (testId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getById1', 'testId', testId)
            const localVarPath = `/api/lab-tests/{testId}`
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} testId 
         * @param {LabTestRequest} labTestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update4: async (testId: string, labTestRequest: LabTestRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('update4', 'testId', testId)
            // verify required parameter 'labTestRequest' is not null or undefined
            assertParamExists('update4', 'labTestRequest', labTestRequest)
            const localVarPath = `/api/lab-tests/{testId}`
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(labTestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LabTestManagementApi - functional programming interface
 */
export const LabTestManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LabTestManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {LabTestRequest} labTestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create4(labTestRequest: LabTestRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseLabTestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create4(labTestRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LabTestManagementApi.create4']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete4(testId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete4(testId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LabTestManagementApi.delete4']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filter5(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePageLabTestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filter5(searchFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LabTestManagementApi.filter5']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById1(testId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseLabTestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById1(testId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LabTestManagementApi.getById1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} testId 
         * @param {LabTestRequest} labTestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update4(testId: string, labTestRequest: LabTestRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseLabTestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update4(testId, labTestRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LabTestManagementApi.update4']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LabTestManagementApi - factory interface
 */
export const LabTestManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LabTestManagementApiFp(configuration)
    return {
        /**
         * 
         * @param {LabTestRequest} labTestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create4(labTestRequest: LabTestRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseLabTestResponse> {
            return localVarFp.create4(labTestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete4(testId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.delete4(testId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filter5(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePageLabTestResponse> {
            return localVarFp.filter5(searchFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById1(testId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseLabTestResponse> {
            return localVarFp.getById1(testId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} testId 
         * @param {LabTestRequest} labTestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update4(testId: string, labTestRequest: LabTestRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseLabTestResponse> {
            return localVarFp.update4(testId, labTestRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LabTestManagementApi - object-oriented interface
 */
export class LabTestManagementApi extends BaseAPI {
    /**
     * 
     * @param {LabTestRequest} labTestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public create4(labTestRequest: LabTestRequest, options?: RawAxiosRequestConfig) {
        return LabTestManagementApiFp(this.configuration).create4(labTestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} testId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public delete4(testId: string, options?: RawAxiosRequestConfig) {
        return LabTestManagementApiFp(this.configuration).delete4(testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SearchFilter} searchFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public filter5(searchFilter: SearchFilter, options?: RawAxiosRequestConfig) {
        return LabTestManagementApiFp(this.configuration).filter5(searchFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} testId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getById1(testId: string, options?: RawAxiosRequestConfig) {
        return LabTestManagementApiFp(this.configuration).getById1(testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} testId 
     * @param {LabTestRequest} labTestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public update4(testId: string, labTestRequest: LabTestRequest, options?: RawAxiosRequestConfig) {
        return LabTestManagementApiFp(this.configuration).update4(testId, labTestRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MedicineManagementApi - axios parameter creator
 */
export const MedicineManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {MedicineRequest} medicineRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create3: async (medicineRequest: MedicineRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'medicineRequest' is not null or undefined
            assertParamExists('create3', 'medicineRequest', medicineRequest)
            const localVarPath = `/api/medicines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(medicineRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} medicineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete3: async (medicineId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'medicineId' is not null or undefined
            assertParamExists('delete3', 'medicineId', medicineId)
            const localVarPath = `/api/medicines/{medicineId}`
                .replace(`{${"medicineId"}}`, encodeURIComponent(String(medicineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filter4: async (searchFilter: SearchFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchFilter' is not null or undefined
            assertParamExists('filter4', 'searchFilter', searchFilter)
            const localVarPath = `/api/medicines/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} medicineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById: async (medicineId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'medicineId' is not null or undefined
            assertParamExists('getById', 'medicineId', medicineId)
            const localVarPath = `/api/medicines/{medicineId}`
                .replace(`{${"medicineId"}}`, encodeURIComponent(String(medicineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} medicineId 
         * @param {MedicineRequest} medicineRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update3: async (medicineId: string, medicineRequest: MedicineRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'medicineId' is not null or undefined
            assertParamExists('update3', 'medicineId', medicineId)
            // verify required parameter 'medicineRequest' is not null or undefined
            assertParamExists('update3', 'medicineRequest', medicineRequest)
            const localVarPath = `/api/medicines/{medicineId}`
                .replace(`{${"medicineId"}}`, encodeURIComponent(String(medicineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(medicineRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MedicineManagementApi - functional programming interface
 */
export const MedicineManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MedicineManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {MedicineRequest} medicineRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create3(medicineRequest: MedicineRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseMedicineResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create3(medicineRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MedicineManagementApi.create3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} medicineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete3(medicineId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete3(medicineId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MedicineManagementApi.delete3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filter4(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePageMedicineResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filter4(searchFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MedicineManagementApi.filter4']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} medicineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById(medicineId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseMedicineResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById(medicineId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MedicineManagementApi.getById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} medicineId 
         * @param {MedicineRequest} medicineRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update3(medicineId: string, medicineRequest: MedicineRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseMedicineResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update3(medicineId, medicineRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MedicineManagementApi.update3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MedicineManagementApi - factory interface
 */
export const MedicineManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MedicineManagementApiFp(configuration)
    return {
        /**
         * 
         * @param {MedicineRequest} medicineRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create3(medicineRequest: MedicineRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseMedicineResponse> {
            return localVarFp.create3(medicineRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} medicineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete3(medicineId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.delete3(medicineId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filter4(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePageMedicineResponse> {
            return localVarFp.filter4(searchFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} medicineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(medicineId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseMedicineResponse> {
            return localVarFp.getById(medicineId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} medicineId 
         * @param {MedicineRequest} medicineRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update3(medicineId: string, medicineRequest: MedicineRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseMedicineResponse> {
            return localVarFp.update3(medicineId, medicineRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MedicineManagementApi - object-oriented interface
 */
export class MedicineManagementApi extends BaseAPI {
    /**
     * 
     * @param {MedicineRequest} medicineRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public create3(medicineRequest: MedicineRequest, options?: RawAxiosRequestConfig) {
        return MedicineManagementApiFp(this.configuration).create3(medicineRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} medicineId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public delete3(medicineId: string, options?: RawAxiosRequestConfig) {
        return MedicineManagementApiFp(this.configuration).delete3(medicineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SearchFilter} searchFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public filter4(searchFilter: SearchFilter, options?: RawAxiosRequestConfig) {
        return MedicineManagementApiFp(this.configuration).filter4(searchFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} medicineId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getById(medicineId: string, options?: RawAxiosRequestConfig) {
        return MedicineManagementApiFp(this.configuration).getById(medicineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} medicineId 
     * @param {MedicineRequest} medicineRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public update3(medicineId: string, medicineRequest: MedicineRequest, options?: RawAxiosRequestConfig) {
        return MedicineManagementApiFp(this.configuration).update3(medicineId, medicineRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PasskeyAuthenticationApi - axios parameter creator
 */
export const PasskeyAuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {FinishLoginRequest} finishLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finishLogin: async (finishLoginRequest: FinishLoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'finishLoginRequest' is not null or undefined
            assertParamExists('finishLogin', 'finishLoginRequest', finishLoginRequest)
            const localVarPath = `/api/auth/passkeys/login/finish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(finishLoginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} credential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finishRegistration: async (credential: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credential' is not null or undefined
            assertParamExists('finishRegistration', 'credential', credential)
            const localVarPath = `/api/auth/passkeys/register/finish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (credential !== undefined) {
                localVarQueryParameter['credential'] = credential;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startLogin: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/passkeys/login/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRegistration: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/passkeys/register/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PasskeyAuthenticationApi - functional programming interface
 */
export const PasskeyAuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PasskeyAuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {FinishLoginRequest} finishLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async finishLogin(finishLoginRequest: FinishLoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseAuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.finishLogin(finishLoginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PasskeyAuthenticationApi.finishLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} credential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async finishRegistration(credential: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.finishRegistration(credential, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PasskeyAuthenticationApi.finishRegistration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startLogin(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseStartPasskeyLoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startLogin(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PasskeyAuthenticationApi.startLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startRegistration(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePublicKeyCredentialCreationOptions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startRegistration(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PasskeyAuthenticationApi.startRegistration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PasskeyAuthenticationApi - factory interface
 */
export const PasskeyAuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PasskeyAuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @param {FinishLoginRequest} finishLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finishLogin(finishLoginRequest: FinishLoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseAuthResponse> {
            return localVarFp.finishLogin(finishLoginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} credential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finishRegistration(credential: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.finishRegistration(credential, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startLogin(options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseStartPasskeyLoginResponse> {
            return localVarFp.startLogin(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRegistration(options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePublicKeyCredentialCreationOptions> {
            return localVarFp.startRegistration(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PasskeyAuthenticationApi - object-oriented interface
 */
export class PasskeyAuthenticationApi extends BaseAPI {
    /**
     * 
     * @param {FinishLoginRequest} finishLoginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public finishLogin(finishLoginRequest: FinishLoginRequest, options?: RawAxiosRequestConfig) {
        return PasskeyAuthenticationApiFp(this.configuration).finishLogin(finishLoginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} credential 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public finishRegistration(credential: string, options?: RawAxiosRequestConfig) {
        return PasskeyAuthenticationApiFp(this.configuration).finishRegistration(credential, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public startLogin(options?: RawAxiosRequestConfig) {
        return PasskeyAuthenticationApiFp(this.configuration).startLogin(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public startRegistration(options?: RawAxiosRequestConfig) {
        return PasskeyAuthenticationApiFp(this.configuration).startRegistration(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PatientManagementApi - axios parameter creator
 */
export const PatientManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [phone] 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkPatientExistence: async (phone?: string, email?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/patients/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (phone !== undefined) {
                localVarQueryParameter['phone'] = phone;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} patientId 
         * @param {AllergyRequest} allergyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllergy: async (patientId: string, allergyRequest: AllergyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'patientId' is not null or undefined
            assertParamExists('createAllergy', 'patientId', patientId)
            // verify required parameter 'allergyRequest' is not null or undefined
            assertParamExists('createAllergy', 'allergyRequest', allergyRequest)
            const localVarPath = `/api/patients/{patientId}/allergies`
                .replace(`{${"patientId"}}`, encodeURIComponent(String(patientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(allergyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} patientId 
         * @param {EmergencyContactRequest} emergencyContactRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmergencyContact: async (patientId: string, emergencyContactRequest: EmergencyContactRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'patientId' is not null or undefined
            assertParamExists('createEmergencyContact', 'patientId', patientId)
            // verify required parameter 'emergencyContactRequest' is not null or undefined
            assertParamExists('createEmergencyContact', 'emergencyContactRequest', emergencyContactRequest)
            const localVarPath = `/api/patients/{patientId}/emergency-contacts`
                .replace(`{${"patientId"}}`, encodeURIComponent(String(patientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emergencyContactRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PatientRequest} patientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPatient: async (patientRequest: PatientRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'patientRequest' is not null or undefined
            assertParamExists('createPatient', 'patientRequest', patientRequest)
            const localVarPath = `/api/patients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patientRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} allergyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllergy: async (allergyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'allergyId' is not null or undefined
            assertParamExists('deleteAllergy', 'allergyId', allergyId)
            const localVarPath = `/api/patients/allergies/{allergyId}`
                .replace(`{${"allergyId"}}`, encodeURIComponent(String(allergyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} contactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmergencyContact: async (contactId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactId' is not null or undefined
            assertParamExists('deleteEmergencyContact', 'contactId', contactId)
            const localVarPath = `/api/patients/emergency-contacts/{contactId}`
                .replace(`{${"contactId"}}`, encodeURIComponent(String(contactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} patientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePatient: async (patientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'patientId' is not null or undefined
            assertParamExists('deletePatient', 'patientId', patientId)
            const localVarPath = `/api/patients/{patientId}`
                .replace(`{${"patientId"}}`, encodeURIComponent(String(patientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filter: async (searchFilter: SearchFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchFilter' is not null or undefined
            assertParamExists('filter', 'searchFilter', searchFilter)
            const localVarPath = `/api/patients/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} patientId 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filterAllergies: async (patientId: string, searchFilter: SearchFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'patientId' is not null or undefined
            assertParamExists('filterAllergies', 'patientId', patientId)
            // verify required parameter 'searchFilter' is not null or undefined
            assertParamExists('filterAllergies', 'searchFilter', searchFilter)
            const localVarPath = `/api/patients/{patientId}/allergies/filter`
                .replace(`{${"patientId"}}`, encodeURIComponent(String(patientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} patientId 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filterEmergencyContacts: async (patientId: string, searchFilter: SearchFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'patientId' is not null or undefined
            assertParamExists('filterEmergencyContacts', 'patientId', patientId)
            // verify required parameter 'searchFilter' is not null or undefined
            assertParamExists('filterEmergencyContacts', 'searchFilter', searchFilter)
            const localVarPath = `/api/patients/{patientId}/emergency-contacts/filter`
                .replace(`{${"patientId"}}`, encodeURIComponent(String(patientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} patientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPatientById: async (patientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'patientId' is not null or undefined
            assertParamExists('getPatientById', 'patientId', patientId)
            const localVarPath = `/api/patients/{patientId}`
                .replace(`{${"patientId"}}`, encodeURIComponent(String(patientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} allergyId 
         * @param {AllergyRequest} allergyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAllergy: async (allergyId: string, allergyRequest: AllergyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'allergyId' is not null or undefined
            assertParamExists('updateAllergy', 'allergyId', allergyId)
            // verify required parameter 'allergyRequest' is not null or undefined
            assertParamExists('updateAllergy', 'allergyRequest', allergyRequest)
            const localVarPath = `/api/patients/allergies/{allergyId}`
                .replace(`{${"allergyId"}}`, encodeURIComponent(String(allergyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(allergyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} contactId 
         * @param {EmergencyContactRequest} emergencyContactRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmergencyContact: async (contactId: string, emergencyContactRequest: EmergencyContactRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactId' is not null or undefined
            assertParamExists('updateEmergencyContact', 'contactId', contactId)
            // verify required parameter 'emergencyContactRequest' is not null or undefined
            assertParamExists('updateEmergencyContact', 'emergencyContactRequest', emergencyContactRequest)
            const localVarPath = `/api/patients/emergency-contacts/{contactId}`
                .replace(`{${"contactId"}}`, encodeURIComponent(String(contactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emergencyContactRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} patientId 
         * @param {PatientRequest} patientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePatient: async (patientId: string, patientRequest: PatientRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'patientId' is not null or undefined
            assertParamExists('updatePatient', 'patientId', patientId)
            // verify required parameter 'patientRequest' is not null or undefined
            assertParamExists('updatePatient', 'patientRequest', patientRequest)
            const localVarPath = `/api/patients/{patientId}`
                .replace(`{${"patientId"}}`, encodeURIComponent(String(patientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patientRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PatientManagementApi - functional programming interface
 */
export const PatientManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PatientManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [phone] 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkPatientExistence(phone?: string, email?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseBoolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkPatientExistence(phone, email, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PatientManagementApi.checkPatientExistence']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} patientId 
         * @param {AllergyRequest} allergyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAllergy(patientId: string, allergyRequest: AllergyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseAllergyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAllergy(patientId, allergyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PatientManagementApi.createAllergy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} patientId 
         * @param {EmergencyContactRequest} emergencyContactRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEmergencyContact(patientId: string, emergencyContactRequest: EmergencyContactRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseEmergencyContactResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEmergencyContact(patientId, emergencyContactRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PatientManagementApi.createEmergencyContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PatientRequest} patientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPatient(patientRequest: PatientRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePatientResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPatient(patientRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PatientManagementApi.createPatient']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} allergyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllergy(allergyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllergy(allergyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PatientManagementApi.deleteAllergy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} contactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEmergencyContact(contactId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEmergencyContact(contactId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PatientManagementApi.deleteEmergencyContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} patientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePatient(patientId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePatient(patientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PatientManagementApi.deletePatient']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filter(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePagePatientResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filter(searchFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PatientManagementApi.filter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} patientId 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filterAllergies(patientId: string, searchFilter: SearchFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePageAllergyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filterAllergies(patientId, searchFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PatientManagementApi.filterAllergies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} patientId 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filterEmergencyContacts(patientId: string, searchFilter: SearchFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePageEmergencyContactResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filterEmergencyContacts(patientId, searchFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PatientManagementApi.filterEmergencyContacts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} patientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPatientById(patientId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePatientResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPatientById(patientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PatientManagementApi.getPatientById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} allergyId 
         * @param {AllergyRequest} allergyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAllergy(allergyId: string, allergyRequest: AllergyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseAllergyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAllergy(allergyId, allergyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PatientManagementApi.updateAllergy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} contactId 
         * @param {EmergencyContactRequest} emergencyContactRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEmergencyContact(contactId: string, emergencyContactRequest: EmergencyContactRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseEmergencyContactResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEmergencyContact(contactId, emergencyContactRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PatientManagementApi.updateEmergencyContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} patientId 
         * @param {PatientRequest} patientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePatient(patientId: string, patientRequest: PatientRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePatientResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePatient(patientId, patientRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PatientManagementApi.updatePatient']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PatientManagementApi - factory interface
 */
export const PatientManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PatientManagementApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [phone] 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkPatientExistence(phone?: string, email?: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseBoolean> {
            return localVarFp.checkPatientExistence(phone, email, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} patientId 
         * @param {AllergyRequest} allergyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllergy(patientId: string, allergyRequest: AllergyRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseAllergyResponse> {
            return localVarFp.createAllergy(patientId, allergyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} patientId 
         * @param {EmergencyContactRequest} emergencyContactRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmergencyContact(patientId: string, emergencyContactRequest: EmergencyContactRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseEmergencyContactResponse> {
            return localVarFp.createEmergencyContact(patientId, emergencyContactRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PatientRequest} patientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPatient(patientRequest: PatientRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePatientResponse> {
            return localVarFp.createPatient(patientRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} allergyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllergy(allergyId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.deleteAllergy(allergyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} contactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmergencyContact(contactId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.deleteEmergencyContact(contactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} patientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePatient(patientId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.deletePatient(patientId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filter(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePagePatientResponse> {
            return localVarFp.filter(searchFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} patientId 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filterAllergies(patientId: string, searchFilter: SearchFilter, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePageAllergyResponse> {
            return localVarFp.filterAllergies(patientId, searchFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} patientId 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filterEmergencyContacts(patientId: string, searchFilter: SearchFilter, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePageEmergencyContactResponse> {
            return localVarFp.filterEmergencyContacts(patientId, searchFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} patientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPatientById(patientId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePatientResponse> {
            return localVarFp.getPatientById(patientId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} allergyId 
         * @param {AllergyRequest} allergyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAllergy(allergyId: string, allergyRequest: AllergyRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseAllergyResponse> {
            return localVarFp.updateAllergy(allergyId, allergyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} contactId 
         * @param {EmergencyContactRequest} emergencyContactRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmergencyContact(contactId: string, emergencyContactRequest: EmergencyContactRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseEmergencyContactResponse> {
            return localVarFp.updateEmergencyContact(contactId, emergencyContactRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} patientId 
         * @param {PatientRequest} patientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePatient(patientId: string, patientRequest: PatientRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePatientResponse> {
            return localVarFp.updatePatient(patientId, patientRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PatientManagementApi - object-oriented interface
 */
export class PatientManagementApi extends BaseAPI {
    /**
     * 
     * @param {string} [phone] 
     * @param {string} [email] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public checkPatientExistence(phone?: string, email?: string, options?: RawAxiosRequestConfig) {
        return PatientManagementApiFp(this.configuration).checkPatientExistence(phone, email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} patientId 
     * @param {AllergyRequest} allergyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createAllergy(patientId: string, allergyRequest: AllergyRequest, options?: RawAxiosRequestConfig) {
        return PatientManagementApiFp(this.configuration).createAllergy(patientId, allergyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} patientId 
     * @param {EmergencyContactRequest} emergencyContactRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createEmergencyContact(patientId: string, emergencyContactRequest: EmergencyContactRequest, options?: RawAxiosRequestConfig) {
        return PatientManagementApiFp(this.configuration).createEmergencyContact(patientId, emergencyContactRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PatientRequest} patientRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createPatient(patientRequest: PatientRequest, options?: RawAxiosRequestConfig) {
        return PatientManagementApiFp(this.configuration).createPatient(patientRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} allergyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteAllergy(allergyId: string, options?: RawAxiosRequestConfig) {
        return PatientManagementApiFp(this.configuration).deleteAllergy(allergyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} contactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteEmergencyContact(contactId: string, options?: RawAxiosRequestConfig) {
        return PatientManagementApiFp(this.configuration).deleteEmergencyContact(contactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} patientId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deletePatient(patientId: string, options?: RawAxiosRequestConfig) {
        return PatientManagementApiFp(this.configuration).deletePatient(patientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SearchFilter} searchFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public filter(searchFilter: SearchFilter, options?: RawAxiosRequestConfig) {
        return PatientManagementApiFp(this.configuration).filter(searchFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} patientId 
     * @param {SearchFilter} searchFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public filterAllergies(patientId: string, searchFilter: SearchFilter, options?: RawAxiosRequestConfig) {
        return PatientManagementApiFp(this.configuration).filterAllergies(patientId, searchFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} patientId 
     * @param {SearchFilter} searchFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public filterEmergencyContacts(patientId: string, searchFilter: SearchFilter, options?: RawAxiosRequestConfig) {
        return PatientManagementApiFp(this.configuration).filterEmergencyContacts(patientId, searchFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} patientId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPatientById(patientId: string, options?: RawAxiosRequestConfig) {
        return PatientManagementApiFp(this.configuration).getPatientById(patientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} allergyId 
     * @param {AllergyRequest} allergyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateAllergy(allergyId: string, allergyRequest: AllergyRequest, options?: RawAxiosRequestConfig) {
        return PatientManagementApiFp(this.configuration).updateAllergy(allergyId, allergyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} contactId 
     * @param {EmergencyContactRequest} emergencyContactRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateEmergencyContact(contactId: string, emergencyContactRequest: EmergencyContactRequest, options?: RawAxiosRequestConfig) {
        return PatientManagementApiFp(this.configuration).updateEmergencyContact(contactId, emergencyContactRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} patientId 
     * @param {PatientRequest} patientRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updatePatient(patientId: string, patientRequest: PatientRequest, options?: RawAxiosRequestConfig) {
        return PatientManagementApiFp(this.configuration).updatePatient(patientId, patientRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PositionManagementApi - axios parameter creator
 */
export const PositionManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create13: async (positionRequest: PositionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'positionRequest' is not null or undefined
            assertParamExists('create13', 'positionRequest', positionRequest)
            const localVarPath = `/api/admin/positions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(positionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete13: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('delete13', 'id', id)
            const localVarPath = `/api/admin/positions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filter15: async (searchFilter: SearchFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchFilter' is not null or undefined
            assertParamExists('filter15', 'searchFilter', searchFilter)
            const localVarPath = `/api/admin/positions/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById9: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getById9', 'id', id)
            const localVarPath = `/api/admin/positions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update13: async (id: string, positionRequest: PositionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update13', 'id', id)
            // verify required parameter 'positionRequest' is not null or undefined
            assertParamExists('update13', 'positionRequest', positionRequest)
            const localVarPath = `/api/admin/positions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(positionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PositionManagementApi - functional programming interface
 */
export const PositionManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PositionManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create13(positionRequest: PositionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePositionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create13(positionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PositionManagementApi.create13']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete13(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete13(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PositionManagementApi.delete13']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filter15(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePagePositionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filter15(searchFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PositionManagementApi.filter15']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById9(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePositionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById9(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PositionManagementApi.getById9']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update13(id: string, positionRequest: PositionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePositionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update13(id, positionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PositionManagementApi.update13']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PositionManagementApi - factory interface
 */
export const PositionManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PositionManagementApiFp(configuration)
    return {
        /**
         * 
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create13(positionRequest: PositionRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePositionResponse> {
            return localVarFp.create13(positionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete13(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.delete13(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filter15(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePagePositionResponse> {
            return localVarFp.filter15(searchFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById9(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePositionResponse> {
            return localVarFp.getById9(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update13(id: string, positionRequest: PositionRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePositionResponse> {
            return localVarFp.update13(id, positionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PositionManagementApi - object-oriented interface
 */
export class PositionManagementApi extends BaseAPI {
    /**
     * 
     * @param {PositionRequest} positionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public create13(positionRequest: PositionRequest, options?: RawAxiosRequestConfig) {
        return PositionManagementApiFp(this.configuration).create13(positionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public delete13(id: string, options?: RawAxiosRequestConfig) {
        return PositionManagementApiFp(this.configuration).delete13(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SearchFilter} searchFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public filter15(searchFilter: SearchFilter, options?: RawAxiosRequestConfig) {
        return PositionManagementApiFp(this.configuration).filter15(searchFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getById9(id: string, options?: RawAxiosRequestConfig) {
        return PositionManagementApiFp(this.configuration).getById9(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {PositionRequest} positionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public update13(id: string, positionRequest: PositionRequest, options?: RawAxiosRequestConfig) {
        return PositionManagementApiFp(this.configuration).update13(id, positionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PrescriptionControllerApi - axios parameter creator
 */
export const PrescriptionControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPrescriptionForExamination: async (id: string, searchFilter: SearchFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPrescriptionForExamination', 'id', id)
            // verify required parameter 'searchFilter' is not null or undefined
            assertParamExists('createPrescriptionForExamination', 'searchFilter', searchFilter)
            const localVarPath = `/api/prescriptions/{id}/items/filter`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {PrescriptionItemRequest} prescriptionItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPrescriptionItem: async (id: string, prescriptionItemRequest: PrescriptionItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPrescriptionItem', 'id', id)
            // verify required parameter 'prescriptionItemRequest' is not null or undefined
            assertParamExists('createPrescriptionItem', 'prescriptionItemRequest', prescriptionItemRequest)
            const localVarPath = `/api/prescriptions/{id}/items`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prescriptionItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePrescriptionItem: async (itemId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('deletePrescriptionItem', 'itemId', itemId)
            const localVarPath = `/api/prescriptions/items/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {PrescriptionItemRequest} prescriptionItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePrescriptionItem: async (itemId: string, prescriptionItemRequest: PrescriptionItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('updatePrescriptionItem', 'itemId', itemId)
            // verify required parameter 'prescriptionItemRequest' is not null or undefined
            assertParamExists('updatePrescriptionItem', 'prescriptionItemRequest', prescriptionItemRequest)
            const localVarPath = `/api/prescriptions/items/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prescriptionItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PrescriptionControllerApi - functional programming interface
 */
export const PrescriptionControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PrescriptionControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPrescriptionForExamination(id: string, searchFilter: SearchFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePagePrescriptionItemResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPrescriptionForExamination(id, searchFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PrescriptionControllerApi.createPrescriptionForExamination']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {PrescriptionItemRequest} prescriptionItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPrescriptionItem(id: string, prescriptionItemRequest: PrescriptionItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePrescriptionItemResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPrescriptionItem(id, prescriptionItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PrescriptionControllerApi.createPrescriptionItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePrescriptionItem(itemId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePrescriptionItem(itemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PrescriptionControllerApi.deletePrescriptionItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} itemId 
         * @param {PrescriptionItemRequest} prescriptionItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePrescriptionItem(itemId: string, prescriptionItemRequest: PrescriptionItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePrescriptionItemResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePrescriptionItem(itemId, prescriptionItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PrescriptionControllerApi.updatePrescriptionItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PrescriptionControllerApi - factory interface
 */
export const PrescriptionControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PrescriptionControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPrescriptionForExamination(id: string, searchFilter: SearchFilter, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePagePrescriptionItemResponse> {
            return localVarFp.createPrescriptionForExamination(id, searchFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {PrescriptionItemRequest} prescriptionItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPrescriptionItem(id: string, prescriptionItemRequest: PrescriptionItemRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePrescriptionItemResponse> {
            return localVarFp.createPrescriptionItem(id, prescriptionItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePrescriptionItem(itemId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.deletePrescriptionItem(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {PrescriptionItemRequest} prescriptionItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePrescriptionItem(itemId: string, prescriptionItemRequest: PrescriptionItemRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePrescriptionItemResponse> {
            return localVarFp.updatePrescriptionItem(itemId, prescriptionItemRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PrescriptionControllerApi - object-oriented interface
 */
export class PrescriptionControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {SearchFilter} searchFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createPrescriptionForExamination(id: string, searchFilter: SearchFilter, options?: RawAxiosRequestConfig) {
        return PrescriptionControllerApiFp(this.configuration).createPrescriptionForExamination(id, searchFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {PrescriptionItemRequest} prescriptionItemRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createPrescriptionItem(id: string, prescriptionItemRequest: PrescriptionItemRequest, options?: RawAxiosRequestConfig) {
        return PrescriptionControllerApiFp(this.configuration).createPrescriptionItem(id, prescriptionItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} itemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deletePrescriptionItem(itemId: string, options?: RawAxiosRequestConfig) {
        return PrescriptionControllerApiFp(this.configuration).deletePrescriptionItem(itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} itemId 
     * @param {PrescriptionItemRequest} prescriptionItemRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updatePrescriptionItem(itemId: string, prescriptionItemRequest: PrescriptionItemRequest, options?: RawAxiosRequestConfig) {
        return PrescriptionControllerApiFp(this.configuration).updatePrescriptionItem(itemId, prescriptionItemRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * QueueTicketManagementApi - axios parameter creator
 */
export const QueueTicketManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} queueTicketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callQueueTicket: async (queueTicketId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueTicketId' is not null or undefined
            assertParamExists('callQueueTicket', 'queueTicketId', queueTicketId)
            const localVarPath = `/api/queue-tickets/{queueTicketId}/call`
                .replace(`{${"queueTicketId"}}`, encodeURIComponent(String(queueTicketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} queueTicketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doneQueueTicket: async (queueTicketId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueTicketId' is not null or undefined
            assertParamExists('doneQueueTicket', 'queueTicketId', queueTicketId)
            const localVarPath = `/api/queue-tickets/{queueTicketId}/done`
                .replace(`{${"queueTicketId"}}`, encodeURIComponent(String(queueTicketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueForDoctorToday: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/queue-tickets/doctor/today`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} queueTicketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requeueQueueTicket: async (queueTicketId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueTicketId' is not null or undefined
            assertParamExists('requeueQueueTicket', 'queueTicketId', queueTicketId)
            const localVarPath = `/api/queue-tickets/{queueTicketId}/requeue`
                .replace(`{${"queueTicketId"}}`, encodeURIComponent(String(queueTicketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} queueTicketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeQueueTicket: async (queueTicketId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueTicketId' is not null or undefined
            assertParamExists('resumeQueueTicket', 'queueTicketId', queueTicketId)
            const localVarPath = `/api/queue-tickets/{queueTicketId}/resume`
                .replace(`{${"queueTicketId"}}`, encodeURIComponent(String(queueTicketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} queueTicketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skipQueueTicket: async (queueTicketId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueTicketId' is not null or undefined
            assertParamExists('skipQueueTicket', 'queueTicketId', queueTicketId)
            const localVarPath = `/api/queue-tickets/{queueTicketId}/skip`
                .replace(`{${"queueTicketId"}}`, encodeURIComponent(String(queueTicketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} queueTicketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startQueueTicket: async (queueTicketId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueTicketId' is not null or undefined
            assertParamExists('startQueueTicket', 'queueTicketId', queueTicketId)
            const localVarPath = `/api/queue-tickets/{queueTicketId}/start`
                .replace(`{${"queueTicketId"}}`, encodeURIComponent(String(queueTicketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} queueTicketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitResultQueueTicket: async (queueTicketId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueTicketId' is not null or undefined
            assertParamExists('waitResultQueueTicket', 'queueTicketId', queueTicketId)
            const localVarPath = `/api/queue-tickets/{queueTicketId}/wait-result`
                .replace(`{${"queueTicketId"}}`, encodeURIComponent(String(queueTicketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueueTicketManagementApi - functional programming interface
 */
export const QueueTicketManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QueueTicketManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} queueTicketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callQueueTicket(queueTicketId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseQueueTicketResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callQueueTicket(queueTicketId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueueTicketManagementApi.callQueueTicket']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} queueTicketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async doneQueueTicket(queueTicketId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseQueueTicketResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.doneQueueTicket(queueTicketId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueueTicketManagementApi.doneQueueTicket']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueueForDoctorToday(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseListQueueTicketResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQueueForDoctorToday(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueueTicketManagementApi.getQueueForDoctorToday']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} queueTicketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requeueQueueTicket(queueTicketId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseQueueTicketResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requeueQueueTicket(queueTicketId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueueTicketManagementApi.requeueQueueTicket']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} queueTicketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resumeQueueTicket(queueTicketId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseQueueTicketResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resumeQueueTicket(queueTicketId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueueTicketManagementApi.resumeQueueTicket']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} queueTicketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skipQueueTicket(queueTicketId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseQueueTicketResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skipQueueTicket(queueTicketId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueueTicketManagementApi.skipQueueTicket']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} queueTicketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startQueueTicket(queueTicketId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseQueueTicketResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startQueueTicket(queueTicketId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueueTicketManagementApi.startQueueTicket']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} queueTicketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitResultQueueTicket(queueTicketId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseQueueTicketResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.waitResultQueueTicket(queueTicketId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueueTicketManagementApi.waitResultQueueTicket']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * QueueTicketManagementApi - factory interface
 */
export const QueueTicketManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueueTicketManagementApiFp(configuration)
    return {
        /**
         * 
         * @param {string} queueTicketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callQueueTicket(queueTicketId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseQueueTicketResponse> {
            return localVarFp.callQueueTicket(queueTicketId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} queueTicketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doneQueueTicket(queueTicketId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseQueueTicketResponse> {
            return localVarFp.doneQueueTicket(queueTicketId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueForDoctorToday(options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseListQueueTicketResponse> {
            return localVarFp.getQueueForDoctorToday(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} queueTicketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requeueQueueTicket(queueTicketId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseQueueTicketResponse> {
            return localVarFp.requeueQueueTicket(queueTicketId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} queueTicketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeQueueTicket(queueTicketId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseQueueTicketResponse> {
            return localVarFp.resumeQueueTicket(queueTicketId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} queueTicketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skipQueueTicket(queueTicketId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseQueueTicketResponse> {
            return localVarFp.skipQueueTicket(queueTicketId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} queueTicketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startQueueTicket(queueTicketId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseQueueTicketResponse> {
            return localVarFp.startQueueTicket(queueTicketId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} queueTicketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitResultQueueTicket(queueTicketId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseQueueTicketResponse> {
            return localVarFp.waitResultQueueTicket(queueTicketId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QueueTicketManagementApi - object-oriented interface
 */
export class QueueTicketManagementApi extends BaseAPI {
    /**
     * 
     * @param {string} queueTicketId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public callQueueTicket(queueTicketId: string, options?: RawAxiosRequestConfig) {
        return QueueTicketManagementApiFp(this.configuration).callQueueTicket(queueTicketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} queueTicketId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public doneQueueTicket(queueTicketId: string, options?: RawAxiosRequestConfig) {
        return QueueTicketManagementApiFp(this.configuration).doneQueueTicket(queueTicketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getQueueForDoctorToday(options?: RawAxiosRequestConfig) {
        return QueueTicketManagementApiFp(this.configuration).getQueueForDoctorToday(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} queueTicketId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public requeueQueueTicket(queueTicketId: string, options?: RawAxiosRequestConfig) {
        return QueueTicketManagementApiFp(this.configuration).requeueQueueTicket(queueTicketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} queueTicketId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resumeQueueTicket(queueTicketId: string, options?: RawAxiosRequestConfig) {
        return QueueTicketManagementApiFp(this.configuration).resumeQueueTicket(queueTicketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} queueTicketId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public skipQueueTicket(queueTicketId: string, options?: RawAxiosRequestConfig) {
        return QueueTicketManagementApiFp(this.configuration).skipQueueTicket(queueTicketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} queueTicketId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public startQueueTicket(queueTicketId: string, options?: RawAxiosRequestConfig) {
        return QueueTicketManagementApiFp(this.configuration).startQueueTicket(queueTicketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} queueTicketId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public waitResultQueueTicket(queueTicketId: string, options?: RawAxiosRequestConfig) {
        return QueueTicketManagementApiFp(this.configuration).waitResultQueueTicket(queueTicketId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportAPIApi - axios parameter creator
 */
export const ReportAPIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} from 
         * @param {string} to 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPatientByDay: async (from: string, to: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getPatientByDay', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getPatientByDay', 'to', to)
            const localVarPath = `/api/admin/report/patient-by-day`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString().substring(0,10) :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString().substring(0,10) :
                    to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPatientByHour: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/admin/report/patient-by-hour`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueStatusToday: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/admin/report/queue-status-today`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} from 
         * @param {string} to 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRevenueDaily: async (from: string, to: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getRevenueDaily', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getRevenueDaily', 'to', to)
            const localVarPath = `/api/admin/report/revenue-daily`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString().substring(0,10) :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString().substring(0,10) :
                    to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} from 
         * @param {string} to 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceUsage: async (from: string, to: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getServiceUsage', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getServiceUsage', 'to', to)
            const localVarPath = `/api/admin/report/service-usage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString().substring(0,10) :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString().substring(0,10) :
                    to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpecialtyDistribution: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/admin/report/patient-specialty`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} from 
         * @param {string} to 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStaffWorkload: async (from: string, to: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getStaffWorkload', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getStaffWorkload', 'to', to)
            const localVarPath = `/api/admin/report/staff-workload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString().substring(0,10) :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString().substring(0,10) :
                    to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTodaySummary: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/admin/report/today`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportAPIApi - functional programming interface
 */
export const ReportAPIApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportAPIApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} from 
         * @param {string} to 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPatientByDay(from: string, to: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseListPatientByDayResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPatientByDay(from, to, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportAPIApi.getPatientByDay']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPatientByHour(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseListPatientByHourResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPatientByHour(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportAPIApi.getPatientByHour']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueueStatusToday(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseMapStringLong>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQueueStatusToday(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportAPIApi.getQueueStatusToday']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} from 
         * @param {string} to 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRevenueDaily(from: string, to: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseListRevenueDailyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRevenueDaily(from, to, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportAPIApi.getRevenueDaily']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} from 
         * @param {string} to 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceUsage(from: string, to: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseListServiceUsageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceUsage(from, to, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportAPIApi.getServiceUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSpecialtyDistribution(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseListSpecialtyDistributionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSpecialtyDistribution(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportAPIApi.getSpecialtyDistribution']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} from 
         * @param {string} to 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStaffWorkload(from: string, to: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseListStaffWorkloadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStaffWorkload(from, to, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportAPIApi.getStaffWorkload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTodaySummary(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseTodaySummaryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTodaySummary(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportAPIApi.getTodaySummary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportAPIApi - factory interface
 */
export const ReportAPIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportAPIApiFp(configuration)
    return {
        /**
         * 
         * @param {string} from 
         * @param {string} to 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPatientByDay(from: string, to: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseListPatientByDayResponse> {
            return localVarFp.getPatientByDay(from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPatientByHour(options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseListPatientByHourResponse> {
            return localVarFp.getPatientByHour(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueStatusToday(options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseMapStringLong> {
            return localVarFp.getQueueStatusToday(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} from 
         * @param {string} to 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRevenueDaily(from: string, to: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseListRevenueDailyResponse> {
            return localVarFp.getRevenueDaily(from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} from 
         * @param {string} to 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceUsage(from: string, to: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseListServiceUsageResponse> {
            return localVarFp.getServiceUsage(from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpecialtyDistribution(options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseListSpecialtyDistributionResponse> {
            return localVarFp.getSpecialtyDistribution(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} from 
         * @param {string} to 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStaffWorkload(from: string, to: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseListStaffWorkloadResponse> {
            return localVarFp.getStaffWorkload(from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTodaySummary(options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseTodaySummaryResponse> {
            return localVarFp.getTodaySummary(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReportAPIApi - object-oriented interface
 */
export class ReportAPIApi extends BaseAPI {
    /**
     * 
     * @param {string} from 
     * @param {string} to 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPatientByDay(from: string, to: string, options?: RawAxiosRequestConfig) {
        return ReportAPIApiFp(this.configuration).getPatientByDay(from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPatientByHour(options?: RawAxiosRequestConfig) {
        return ReportAPIApiFp(this.configuration).getPatientByHour(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getQueueStatusToday(options?: RawAxiosRequestConfig) {
        return ReportAPIApiFp(this.configuration).getQueueStatusToday(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} from 
     * @param {string} to 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRevenueDaily(from: string, to: string, options?: RawAxiosRequestConfig) {
        return ReportAPIApiFp(this.configuration).getRevenueDaily(from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} from 
     * @param {string} to 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getServiceUsage(from: string, to: string, options?: RawAxiosRequestConfig) {
        return ReportAPIApiFp(this.configuration).getServiceUsage(from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSpecialtyDistribution(options?: RawAxiosRequestConfig) {
        return ReportAPIApiFp(this.configuration).getSpecialtyDistribution(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} from 
     * @param {string} to 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getStaffWorkload(from: string, to: string, options?: RawAxiosRequestConfig) {
        return ReportAPIApiFp(this.configuration).getStaffWorkload(from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTodaySummary(options?: RawAxiosRequestConfig) {
        return ReportAPIApiFp(this.configuration).getTodaySummary(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RoomsManagementApi - axios parameter creator
 */
export const RoomsManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('_delete', 'id', id)
            const localVarPath = `/api/organization/rooms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RoomRequest} roomRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (roomRequest: RoomRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomRequest' is not null or undefined
            assertParamExists('create', 'roomRequest', roomRequest)
            const localVarPath = `/api/organization/rooms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roomRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filter1: async (searchFilter: SearchFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchFilter' is not null or undefined
            assertParamExists('filter1', 'searchFilter', searchFilter)
            const localVarPath = `/api/organization/rooms/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRoomById', 'id', id)
            const localVarPath = `/api/organization/rooms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {RoomRequest} roomRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, roomRequest: RoomRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            // verify required parameter 'roomRequest' is not null or undefined
            assertParamExists('update', 'roomRequest', roomRequest)
            const localVarPath = `/api/organization/rooms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roomRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoomsManagementApi - functional programming interface
 */
export const RoomsManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoomsManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsManagementApi._delete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RoomRequest} roomRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(roomRequest: RoomRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseRoomResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(roomRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsManagementApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filter1(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePageRoomResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filter1(searchFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsManagementApi.filter1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseRoomResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoomById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsManagementApi.getRoomById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {RoomRequest} roomRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, roomRequest: RoomRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseRoomResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, roomRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsManagementApi.update']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RoomsManagementApi - factory interface
 */
export const RoomsManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoomsManagementApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp._delete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RoomRequest} roomRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(roomRequest: RoomRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseRoomResponse> {
            return localVarFp.create(roomRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filter1(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePageRoomResponse> {
            return localVarFp.filter1(searchFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseRoomResponse> {
            return localVarFp.getRoomById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {RoomRequest} roomRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id: string, roomRequest: RoomRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseRoomResponse> {
            return localVarFp.update(id, roomRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoomsManagementApi - object-oriented interface
 */
export class RoomsManagementApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public _delete(id: string, options?: RawAxiosRequestConfig) {
        return RoomsManagementApiFp(this.configuration)._delete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RoomRequest} roomRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public create(roomRequest: RoomRequest, options?: RawAxiosRequestConfig) {
        return RoomsManagementApiFp(this.configuration).create(roomRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SearchFilter} searchFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public filter1(searchFilter: SearchFilter, options?: RawAxiosRequestConfig) {
        return RoomsManagementApiFp(this.configuration).filter1(searchFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRoomById(id: string, options?: RawAxiosRequestConfig) {
        return RoomsManagementApiFp(this.configuration).getRoomById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {RoomRequest} roomRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public update(id: string, roomRequest: RoomRequest, options?: RawAxiosRequestConfig) {
        return RoomsManagementApiFp(this.configuration).update(id, roomRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServiceCatalogControllerApi - axios parameter creator
 */
export const ServiceCatalogControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ServiceCatalogRequest} serviceCatalogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create7: async (serviceCatalogRequest: ServiceCatalogRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceCatalogRequest' is not null or undefined
            assertParamExists('create7', 'serviceCatalogRequest', serviceCatalogRequest)
            const localVarPath = `/api/examinations/service-catalog`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceCatalogRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete7: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('delete7', 'id', id)
            const localVarPath = `/api/examinations/service-catalog/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListServiceCatalogs: async (searchFilter: SearchFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchFilter' is not null or undefined
            assertParamExists('getListServiceCatalogs', 'searchFilter', searchFilter)
            const localVarPath = `/api/examinations/service-catalog/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {ServiceCatalogRequest} serviceCatalogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update7: async (id: string, serviceCatalogRequest: ServiceCatalogRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update7', 'id', id)
            // verify required parameter 'serviceCatalogRequest' is not null or undefined
            assertParamExists('update7', 'serviceCatalogRequest', serviceCatalogRequest)
            const localVarPath = `/api/examinations/service-catalog/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceCatalogRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceCatalogControllerApi - functional programming interface
 */
export const ServiceCatalogControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceCatalogControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ServiceCatalogRequest} serviceCatalogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create7(serviceCatalogRequest: ServiceCatalogRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseServiceCatalogResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create7(serviceCatalogRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceCatalogControllerApi.create7']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete7(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete7(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceCatalogControllerApi.delete7']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListServiceCatalogs(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePageServiceCatalogResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListServiceCatalogs(searchFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceCatalogControllerApi.getListServiceCatalogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {ServiceCatalogRequest} serviceCatalogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update7(id: string, serviceCatalogRequest: ServiceCatalogRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseServiceCatalogResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update7(id, serviceCatalogRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceCatalogControllerApi.update7']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ServiceCatalogControllerApi - factory interface
 */
export const ServiceCatalogControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceCatalogControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {ServiceCatalogRequest} serviceCatalogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create7(serviceCatalogRequest: ServiceCatalogRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseServiceCatalogResponse> {
            return localVarFp.create7(serviceCatalogRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete7(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.delete7(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListServiceCatalogs(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePageServiceCatalogResponse> {
            return localVarFp.getListServiceCatalogs(searchFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {ServiceCatalogRequest} serviceCatalogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update7(id: string, serviceCatalogRequest: ServiceCatalogRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseServiceCatalogResponse> {
            return localVarFp.update7(id, serviceCatalogRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServiceCatalogControllerApi - object-oriented interface
 */
export class ServiceCatalogControllerApi extends BaseAPI {
    /**
     * 
     * @param {ServiceCatalogRequest} serviceCatalogRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public create7(serviceCatalogRequest: ServiceCatalogRequest, options?: RawAxiosRequestConfig) {
        return ServiceCatalogControllerApiFp(this.configuration).create7(serviceCatalogRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public delete7(id: string, options?: RawAxiosRequestConfig) {
        return ServiceCatalogControllerApiFp(this.configuration).delete7(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SearchFilter} searchFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getListServiceCatalogs(searchFilter: SearchFilter, options?: RawAxiosRequestConfig) {
        return ServiceCatalogControllerApiFp(this.configuration).getListServiceCatalogs(searchFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {ServiceCatalogRequest} serviceCatalogRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public update7(id: string, serviceCatalogRequest: ServiceCatalogRequest, options?: RawAxiosRequestConfig) {
        return ServiceCatalogControllerApiFp(this.configuration).update7(id, serviceCatalogRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServiceOrderControllerApi - axios parameter creator
 */
export const ServiceOrderControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceOrderDetail: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getServiceOrderDetail', 'id', id)
            const localVarPath = `/api/service-orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceOrdersForFilters: async (searchFilter: SearchFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchFilter' is not null or undefined
            assertParamExists('getServiceOrdersForFilters', 'searchFilter', searchFilter)
            const localVarPath = `/api/service-orders/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceOrdersForStaffToday: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/service-orders/staff/today`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {ServiceOrderRequest} serviceOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateServiceOrder: async (id: string, serviceOrderRequest: ServiceOrderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateServiceOrder', 'id', id)
            // verify required parameter 'serviceOrderRequest' is not null or undefined
            assertParamExists('updateServiceOrder', 'serviceOrderRequest', serviceOrderRequest)
            const localVarPath = `/api/service-orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceOrderControllerApi - functional programming interface
 */
export const ServiceOrderControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceOrderControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceOrderDetail(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseServiceOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceOrderDetail(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceOrderControllerApi.getServiceOrderDetail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceOrdersForFilters(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePageServiceOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceOrdersForFilters(searchFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceOrderControllerApi.getServiceOrdersForFilters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceOrdersForStaffToday(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseListServiceOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceOrdersForStaffToday(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceOrderControllerApi.getServiceOrdersForStaffToday']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {ServiceOrderRequest} serviceOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateServiceOrder(id: string, serviceOrderRequest: ServiceOrderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseServiceOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateServiceOrder(id, serviceOrderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceOrderControllerApi.updateServiceOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ServiceOrderControllerApi - factory interface
 */
export const ServiceOrderControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceOrderControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceOrderDetail(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseServiceOrderResponse> {
            return localVarFp.getServiceOrderDetail(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceOrdersForFilters(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePageServiceOrderResponse> {
            return localVarFp.getServiceOrdersForFilters(searchFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceOrdersForStaffToday(options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseListServiceOrderResponse> {
            return localVarFp.getServiceOrdersForStaffToday(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {ServiceOrderRequest} serviceOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateServiceOrder(id: string, serviceOrderRequest: ServiceOrderRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseServiceOrderResponse> {
            return localVarFp.updateServiceOrder(id, serviceOrderRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServiceOrderControllerApi - object-oriented interface
 */
export class ServiceOrderControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getServiceOrderDetail(id: string, options?: RawAxiosRequestConfig) {
        return ServiceOrderControllerApiFp(this.configuration).getServiceOrderDetail(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SearchFilter} searchFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getServiceOrdersForFilters(searchFilter: SearchFilter, options?: RawAxiosRequestConfig) {
        return ServiceOrderControllerApiFp(this.configuration).getServiceOrdersForFilters(searchFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getServiceOrdersForStaffToday(options?: RawAxiosRequestConfig) {
        return ServiceOrderControllerApiFp(this.configuration).getServiceOrdersForStaffToday(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {ServiceOrderRequest} serviceOrderRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateServiceOrder(id: string, serviceOrderRequest: ServiceOrderRequest, options?: RawAxiosRequestConfig) {
        return ServiceOrderControllerApiFp(this.configuration).updateServiceOrder(id, serviceOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServiceOrderItemControllerApi - axios parameter creator
 */
export const ServiceOrderItemControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {ServiceOrderItemRequest} serviceOrderItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateServiceOrderItem: async (id: string, serviceOrderItemRequest: ServiceOrderItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateServiceOrderItem', 'id', id)
            // verify required parameter 'serviceOrderItemRequest' is not null or undefined
            assertParamExists('updateServiceOrderItem', 'serviceOrderItemRequest', serviceOrderItemRequest)
            const localVarPath = `/api/service-order-items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceOrderItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceOrderItemControllerApi - functional programming interface
 */
export const ServiceOrderItemControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceOrderItemControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {ServiceOrderItemRequest} serviceOrderItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateServiceOrderItem(id: string, serviceOrderItemRequest: ServiceOrderItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateServiceOrderItem(id, serviceOrderItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceOrderItemControllerApi.updateServiceOrderItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ServiceOrderItemControllerApi - factory interface
 */
export const ServiceOrderItemControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceOrderItemControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {ServiceOrderItemRequest} serviceOrderItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateServiceOrderItem(id: string, serviceOrderItemRequest: ServiceOrderItemRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseObject> {
            return localVarFp.updateServiceOrderItem(id, serviceOrderItemRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServiceOrderItemControllerApi - object-oriented interface
 */
export class ServiceOrderItemControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {ServiceOrderItemRequest} serviceOrderItemRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateServiceOrderItem(id: string, serviceOrderItemRequest: ServiceOrderItemRequest, options?: RawAxiosRequestConfig) {
        return ServiceOrderItemControllerApiFp(this.configuration).updateServiceOrderItem(id, serviceOrderItemRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SpecialtyManagementApi - axios parameter creator
 */
export const SpecialtyManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SpecialtyRequest} specialtyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create12: async (specialtyRequest: SpecialtyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'specialtyRequest' is not null or undefined
            assertParamExists('create12', 'specialtyRequest', specialtyRequest)
            const localVarPath = `/api/admin/specialties`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(specialtyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete12: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('delete12', 'id', id)
            const localVarPath = `/api/admin/specialties/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filter14: async (searchFilter: SearchFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchFilter' is not null or undefined
            assertParamExists('filter14', 'searchFilter', searchFilter)
            const localVarPath = `/api/admin/specialties/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById8: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getById8', 'id', id)
            const localVarPath = `/api/admin/specialties/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {SpecialtyRequest} specialtyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update12: async (id: string, specialtyRequest: SpecialtyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update12', 'id', id)
            // verify required parameter 'specialtyRequest' is not null or undefined
            assertParamExists('update12', 'specialtyRequest', specialtyRequest)
            const localVarPath = `/api/admin/specialties/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(specialtyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SpecialtyManagementApi - functional programming interface
 */
export const SpecialtyManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SpecialtyManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {SpecialtyRequest} specialtyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create12(specialtyRequest: SpecialtyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseSpecialtyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create12(specialtyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpecialtyManagementApi.create12']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete12(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete12(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpecialtyManagementApi.delete12']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filter14(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePageSpecialtyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filter14(searchFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpecialtyManagementApi.filter14']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById8(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseSpecialtyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById8(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpecialtyManagementApi.getById8']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {SpecialtyRequest} specialtyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update12(id: string, specialtyRequest: SpecialtyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseSpecialtyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update12(id, specialtyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpecialtyManagementApi.update12']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SpecialtyManagementApi - factory interface
 */
export const SpecialtyManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SpecialtyManagementApiFp(configuration)
    return {
        /**
         * 
         * @param {SpecialtyRequest} specialtyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create12(specialtyRequest: SpecialtyRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseSpecialtyResponse> {
            return localVarFp.create12(specialtyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete12(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.delete12(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filter14(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePageSpecialtyResponse> {
            return localVarFp.filter14(searchFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById8(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseSpecialtyResponse> {
            return localVarFp.getById8(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {SpecialtyRequest} specialtyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update12(id: string, specialtyRequest: SpecialtyRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseSpecialtyResponse> {
            return localVarFp.update12(id, specialtyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SpecialtyManagementApi - object-oriented interface
 */
export class SpecialtyManagementApi extends BaseAPI {
    /**
     * 
     * @param {SpecialtyRequest} specialtyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public create12(specialtyRequest: SpecialtyRequest, options?: RawAxiosRequestConfig) {
        return SpecialtyManagementApiFp(this.configuration).create12(specialtyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public delete12(id: string, options?: RawAxiosRequestConfig) {
        return SpecialtyManagementApiFp(this.configuration).delete12(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SearchFilter} searchFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public filter14(searchFilter: SearchFilter, options?: RawAxiosRequestConfig) {
        return SpecialtyManagementApiFp(this.configuration).filter14(searchFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getById8(id: string, options?: RawAxiosRequestConfig) {
        return SpecialtyManagementApiFp(this.configuration).getById8(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {SpecialtyRequest} specialtyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public update12(id: string, specialtyRequest: SpecialtyRequest, options?: RawAxiosRequestConfig) {
        return SpecialtyManagementApiFp(this.configuration).update12(id, specialtyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StaffManagementApi - axios parameter creator
 */
export const StaffManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {StaffRequest} staffRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create11: async (staffRequest: StaffRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'staffRequest' is not null or undefined
            assertParamExists('create11', 'staffRequest', staffRequest)
            const localVarPath = `/api/admin/staffs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(staffRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} staffId 
         * @param {StaffScheduleRequest} staffScheduleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStaffSchedule: async (staffId: string, staffScheduleRequest: StaffScheduleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'staffId' is not null or undefined
            assertParamExists('createStaffSchedule', 'staffId', staffId)
            // verify required parameter 'staffScheduleRequest' is not null or undefined
            assertParamExists('createStaffSchedule', 'staffScheduleRequest', staffScheduleRequest)
            const localVarPath = `/api/admin/staffs/{staffId}/schedule`
                .replace(`{${"staffId"}}`, encodeURIComponent(String(staffId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(staffScheduleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} staffId 
         * @param {StaffScheduleTemplateRequest} staffScheduleTemplateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStaffScheduleTemplate: async (staffId: string, staffScheduleTemplateRequest: StaffScheduleTemplateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'staffId' is not null or undefined
            assertParamExists('createStaffScheduleTemplate', 'staffId', staffId)
            // verify required parameter 'staffScheduleTemplateRequest' is not null or undefined
            assertParamExists('createStaffScheduleTemplate', 'staffScheduleTemplateRequest', staffScheduleTemplateRequest)
            const localVarPath = `/api/admin/staffs/{staffId}/schedule-template`
                .replace(`{${"staffId"}}`, encodeURIComponent(String(staffId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(staffScheduleTemplateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {StaffScheduleDayOffRequest} staffScheduleDayOffRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dayOff: async (staffScheduleDayOffRequest: StaffScheduleDayOffRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'staffScheduleDayOffRequest' is not null or undefined
            assertParamExists('dayOff', 'staffScheduleDayOffRequest', staffScheduleDayOffRequest)
            const localVarPath = `/api/admin/staffs/schedule/day-off`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(staffScheduleDayOffRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete11: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('delete11', 'id', id)
            const localVarPath = `/api/admin/staffs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStaffSchedule: async (scheduleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('deleteStaffSchedule', 'scheduleId', scheduleId)
            const localVarPath = `/api/admin/staffs/schedule/{scheduleId}`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStaffScheduleTemplate: async (templateId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('deleteStaffScheduleTemplate', 'templateId', templateId)
            const localVarPath = `/api/admin/staffs/schedule-template/{templateId}`
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filter13: async (searchFilter: SearchFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchFilter' is not null or undefined
            assertParamExists('filter13', 'searchFilter', searchFilter)
            const localVarPath = `/api/admin/staffs/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} staffId 
         * @param {StaffScheduleGenerateRequest} [staffScheduleGenerateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generate: async (staffId: string, staffScheduleGenerateRequest?: StaffScheduleGenerateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'staffId' is not null or undefined
            assertParamExists('generate', 'staffId', staffId)
            const localVarPath = `/api/admin/staffs/{staffId}/schedule/generate`
                .replace(`{${"staffId"}}`, encodeURIComponent(String(staffId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(staffScheduleGenerateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById7: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getById7', 'id', id)
            const localVarPath = `/api/admin/staffs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMySchedule: async (searchFilter: SearchFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchFilter' is not null or undefined
            assertParamExists('getMySchedule', 'searchFilter', searchFilter)
            const localVarPath = `/api/admin/staffs/schedule/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} staffId 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStaffSchedule: async (staffId: string, searchFilter: SearchFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'staffId' is not null or undefined
            assertParamExists('getStaffSchedule', 'staffId', staffId)
            // verify required parameter 'searchFilter' is not null or undefined
            assertParamExists('getStaffSchedule', 'searchFilter', searchFilter)
            const localVarPath = `/api/admin/staffs/{staffId}/schedule/filter`
                .replace(`{${"staffId"}}`, encodeURIComponent(String(staffId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} staffId 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStaffScheduleTemplate: async (staffId: string, searchFilter: SearchFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'staffId' is not null or undefined
            assertParamExists('getStaffScheduleTemplate', 'staffId', staffId)
            // verify required parameter 'searchFilter' is not null or undefined
            assertParamExists('getStaffScheduleTemplate', 'searchFilter', searchFilter)
            const localVarPath = `/api/admin/staffs/{staffId}/schedule-template/filter`
                .replace(`{${"staffId"}}`, encodeURIComponent(String(staffId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} scheduleId 
         * @param {MarkStatusStatusEnum} status 
         * @param {string} [note] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markStatus: async (scheduleId: string, status: MarkStatusStatusEnum, note?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('markStatus', 'scheduleId', scheduleId)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('markStatus', 'status', status)
            const localVarPath = `/api/admin/staffs/schedule/{scheduleId}/status`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (note !== undefined) {
                localVarQueryParameter['note'] = note;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} from 
         * @param {string} to 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myRange: async (from: string, to: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'from' is not null or undefined
            assertParamExists('myRange', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('myRange', 'to', to)
            const localVarPath = `/api/admin/staffs/schedule`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString().substring(0,10) :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString().substring(0,10) :
                    to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} staffId 
         * @param {string} from 
         * @param {string} to 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        range: async (staffId: string, from: string, to: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'staffId' is not null or undefined
            assertParamExists('range', 'staffId', staffId)
            // verify required parameter 'from' is not null or undefined
            assertParamExists('range', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('range', 'to', to)
            const localVarPath = `/api/admin/staffs/{staffId}/schedule`
                .replace(`{${"staffId"}}`, encodeURIComponent(String(staffId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString().substring(0,10) :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString().substring(0,10) :
                    to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {StaffRequest} staffRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update11: async (id: string, staffRequest: StaffRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update11', 'id', id)
            // verify required parameter 'staffRequest' is not null or undefined
            assertParamExists('update11', 'staffRequest', staffRequest)
            const localVarPath = `/api/admin/staffs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(staffRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} scheduleId 
         * @param {StaffScheduleRequest} staffScheduleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStaffSchedule: async (scheduleId: string, staffScheduleRequest: StaffScheduleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('updateStaffSchedule', 'scheduleId', scheduleId)
            // verify required parameter 'staffScheduleRequest' is not null or undefined
            assertParamExists('updateStaffSchedule', 'staffScheduleRequest', staffScheduleRequest)
            const localVarPath = `/api/admin/staffs/schedule/{scheduleId}`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(staffScheduleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} templateId 
         * @param {StaffScheduleTemplateRequest} staffScheduleTemplateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStaffScheduleTemplate: async (templateId: string, staffScheduleTemplateRequest: StaffScheduleTemplateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('updateStaffScheduleTemplate', 'templateId', templateId)
            // verify required parameter 'staffScheduleTemplateRequest' is not null or undefined
            assertParamExists('updateStaffScheduleTemplate', 'staffScheduleTemplateRequest', staffScheduleTemplateRequest)
            const localVarPath = `/api/admin/staffs/schedule-template/{templateId}`
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(staffScheduleTemplateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StaffManagementApi - functional programming interface
 */
export const StaffManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StaffManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {StaffRequest} staffRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create11(staffRequest: StaffRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseStaffResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create11(staffRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StaffManagementApi.create11']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} staffId 
         * @param {StaffScheduleRequest} staffScheduleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStaffSchedule(staffId: string, staffScheduleRequest: StaffScheduleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseStaffScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStaffSchedule(staffId, staffScheduleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StaffManagementApi.createStaffSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} staffId 
         * @param {StaffScheduleTemplateRequest} staffScheduleTemplateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStaffScheduleTemplate(staffId: string, staffScheduleTemplateRequest: StaffScheduleTemplateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseStaffScheduleTemplateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStaffScheduleTemplate(staffId, staffScheduleTemplateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StaffManagementApi.createStaffScheduleTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {StaffScheduleDayOffRequest} staffScheduleDayOffRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dayOff(staffScheduleDayOffRequest: StaffScheduleDayOffRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseStaffScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dayOff(staffScheduleDayOffRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StaffManagementApi.dayOff']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete11(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete11(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StaffManagementApi.delete11']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStaffSchedule(scheduleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStaffSchedule(scheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StaffManagementApi.deleteStaffSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStaffScheduleTemplate(templateId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStaffScheduleTemplate(templateId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StaffManagementApi.deleteStaffScheduleTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filter13(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePageStaffResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filter13(searchFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StaffManagementApi.filter13']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} staffId 
         * @param {StaffScheduleGenerateRequest} [staffScheduleGenerateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generate(staffId: string, staffScheduleGenerateRequest?: StaffScheduleGenerateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generate(staffId, staffScheduleGenerateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StaffManagementApi.generate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById7(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseStaffResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById7(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StaffManagementApi.getById7']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMySchedule(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePageStaffScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMySchedule(searchFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StaffManagementApi.getMySchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} staffId 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStaffSchedule(staffId: string, searchFilter: SearchFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePageStaffScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStaffSchedule(staffId, searchFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StaffManagementApi.getStaffSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} staffId 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStaffScheduleTemplate(staffId: string, searchFilter: SearchFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePageStaffScheduleTemplateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStaffScheduleTemplate(staffId, searchFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StaffManagementApi.getStaffScheduleTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} scheduleId 
         * @param {MarkStatusStatusEnum} status 
         * @param {string} [note] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markStatus(scheduleId: string, status: MarkStatusStatusEnum, note?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseStaffScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markStatus(scheduleId, status, note, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StaffManagementApi.markStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} from 
         * @param {string} to 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async myRange(from: string, to: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseListStaffScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.myRange(from, to, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StaffManagementApi.myRange']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} staffId 
         * @param {string} from 
         * @param {string} to 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async range(staffId: string, from: string, to: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseListStaffScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.range(staffId, from, to, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StaffManagementApi.range']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {StaffRequest} staffRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update11(id: string, staffRequest: StaffRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseStaffResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update11(id, staffRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StaffManagementApi.update11']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} scheduleId 
         * @param {StaffScheduleRequest} staffScheduleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStaffSchedule(scheduleId: string, staffScheduleRequest: StaffScheduleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseStaffScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStaffSchedule(scheduleId, staffScheduleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StaffManagementApi.updateStaffSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} templateId 
         * @param {StaffScheduleTemplateRequest} staffScheduleTemplateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStaffScheduleTemplate(templateId: string, staffScheduleTemplateRequest: StaffScheduleTemplateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseStaffScheduleTemplateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStaffScheduleTemplate(templateId, staffScheduleTemplateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StaffManagementApi.updateStaffScheduleTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StaffManagementApi - factory interface
 */
export const StaffManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StaffManagementApiFp(configuration)
    return {
        /**
         * 
         * @param {StaffRequest} staffRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create11(staffRequest: StaffRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseStaffResponse> {
            return localVarFp.create11(staffRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} staffId 
         * @param {StaffScheduleRequest} staffScheduleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStaffSchedule(staffId: string, staffScheduleRequest: StaffScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseStaffScheduleResponse> {
            return localVarFp.createStaffSchedule(staffId, staffScheduleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} staffId 
         * @param {StaffScheduleTemplateRequest} staffScheduleTemplateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStaffScheduleTemplate(staffId: string, staffScheduleTemplateRequest: StaffScheduleTemplateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseStaffScheduleTemplateResponse> {
            return localVarFp.createStaffScheduleTemplate(staffId, staffScheduleTemplateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {StaffScheduleDayOffRequest} staffScheduleDayOffRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dayOff(staffScheduleDayOffRequest: StaffScheduleDayOffRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseStaffScheduleResponse> {
            return localVarFp.dayOff(staffScheduleDayOffRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete11(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.delete11(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStaffSchedule(scheduleId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.deleteStaffSchedule(scheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStaffScheduleTemplate(templateId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.deleteStaffScheduleTemplate(templateId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filter13(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePageStaffResponse> {
            return localVarFp.filter13(searchFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} staffId 
         * @param {StaffScheduleGenerateRequest} [staffScheduleGenerateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generate(staffId: string, staffScheduleGenerateRequest?: StaffScheduleGenerateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.generate(staffId, staffScheduleGenerateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById7(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseStaffResponse> {
            return localVarFp.getById7(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMySchedule(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePageStaffScheduleResponse> {
            return localVarFp.getMySchedule(searchFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} staffId 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStaffSchedule(staffId: string, searchFilter: SearchFilter, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePageStaffScheduleResponse> {
            return localVarFp.getStaffSchedule(staffId, searchFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} staffId 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStaffScheduleTemplate(staffId: string, searchFilter: SearchFilter, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePageStaffScheduleTemplateResponse> {
            return localVarFp.getStaffScheduleTemplate(staffId, searchFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} scheduleId 
         * @param {MarkStatusStatusEnum} status 
         * @param {string} [note] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markStatus(scheduleId: string, status: MarkStatusStatusEnum, note?: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseStaffScheduleResponse> {
            return localVarFp.markStatus(scheduleId, status, note, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} from 
         * @param {string} to 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myRange(from: string, to: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseListStaffScheduleResponse> {
            return localVarFp.myRange(from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} staffId 
         * @param {string} from 
         * @param {string} to 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        range(staffId: string, from: string, to: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseListStaffScheduleResponse> {
            return localVarFp.range(staffId, from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {StaffRequest} staffRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update11(id: string, staffRequest: StaffRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseStaffResponse> {
            return localVarFp.update11(id, staffRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} scheduleId 
         * @param {StaffScheduleRequest} staffScheduleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStaffSchedule(scheduleId: string, staffScheduleRequest: StaffScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseStaffScheduleResponse> {
            return localVarFp.updateStaffSchedule(scheduleId, staffScheduleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} templateId 
         * @param {StaffScheduleTemplateRequest} staffScheduleTemplateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStaffScheduleTemplate(templateId: string, staffScheduleTemplateRequest: StaffScheduleTemplateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseStaffScheduleTemplateResponse> {
            return localVarFp.updateStaffScheduleTemplate(templateId, staffScheduleTemplateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StaffManagementApi - object-oriented interface
 */
export class StaffManagementApi extends BaseAPI {
    /**
     * 
     * @param {StaffRequest} staffRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public create11(staffRequest: StaffRequest, options?: RawAxiosRequestConfig) {
        return StaffManagementApiFp(this.configuration).create11(staffRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} staffId 
     * @param {StaffScheduleRequest} staffScheduleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createStaffSchedule(staffId: string, staffScheduleRequest: StaffScheduleRequest, options?: RawAxiosRequestConfig) {
        return StaffManagementApiFp(this.configuration).createStaffSchedule(staffId, staffScheduleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} staffId 
     * @param {StaffScheduleTemplateRequest} staffScheduleTemplateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createStaffScheduleTemplate(staffId: string, staffScheduleTemplateRequest: StaffScheduleTemplateRequest, options?: RawAxiosRequestConfig) {
        return StaffManagementApiFp(this.configuration).createStaffScheduleTemplate(staffId, staffScheduleTemplateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {StaffScheduleDayOffRequest} staffScheduleDayOffRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public dayOff(staffScheduleDayOffRequest: StaffScheduleDayOffRequest, options?: RawAxiosRequestConfig) {
        return StaffManagementApiFp(this.configuration).dayOff(staffScheduleDayOffRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public delete11(id: string, options?: RawAxiosRequestConfig) {
        return StaffManagementApiFp(this.configuration).delete11(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} scheduleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteStaffSchedule(scheduleId: string, options?: RawAxiosRequestConfig) {
        return StaffManagementApiFp(this.configuration).deleteStaffSchedule(scheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} templateId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteStaffScheduleTemplate(templateId: string, options?: RawAxiosRequestConfig) {
        return StaffManagementApiFp(this.configuration).deleteStaffScheduleTemplate(templateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SearchFilter} searchFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public filter13(searchFilter: SearchFilter, options?: RawAxiosRequestConfig) {
        return StaffManagementApiFp(this.configuration).filter13(searchFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} staffId 
     * @param {StaffScheduleGenerateRequest} [staffScheduleGenerateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public generate(staffId: string, staffScheduleGenerateRequest?: StaffScheduleGenerateRequest, options?: RawAxiosRequestConfig) {
        return StaffManagementApiFp(this.configuration).generate(staffId, staffScheduleGenerateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getById7(id: string, options?: RawAxiosRequestConfig) {
        return StaffManagementApiFp(this.configuration).getById7(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SearchFilter} searchFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMySchedule(searchFilter: SearchFilter, options?: RawAxiosRequestConfig) {
        return StaffManagementApiFp(this.configuration).getMySchedule(searchFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} staffId 
     * @param {SearchFilter} searchFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getStaffSchedule(staffId: string, searchFilter: SearchFilter, options?: RawAxiosRequestConfig) {
        return StaffManagementApiFp(this.configuration).getStaffSchedule(staffId, searchFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} staffId 
     * @param {SearchFilter} searchFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getStaffScheduleTemplate(staffId: string, searchFilter: SearchFilter, options?: RawAxiosRequestConfig) {
        return StaffManagementApiFp(this.configuration).getStaffScheduleTemplate(staffId, searchFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} scheduleId 
     * @param {MarkStatusStatusEnum} status 
     * @param {string} [note] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public markStatus(scheduleId: string, status: MarkStatusStatusEnum, note?: string, options?: RawAxiosRequestConfig) {
        return StaffManagementApiFp(this.configuration).markStatus(scheduleId, status, note, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} from 
     * @param {string} to 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public myRange(from: string, to: string, options?: RawAxiosRequestConfig) {
        return StaffManagementApiFp(this.configuration).myRange(from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} staffId 
     * @param {string} from 
     * @param {string} to 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public range(staffId: string, from: string, to: string, options?: RawAxiosRequestConfig) {
        return StaffManagementApiFp(this.configuration).range(staffId, from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {StaffRequest} staffRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public update11(id: string, staffRequest: StaffRequest, options?: RawAxiosRequestConfig) {
        return StaffManagementApiFp(this.configuration).update11(id, staffRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} scheduleId 
     * @param {StaffScheduleRequest} staffScheduleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateStaffSchedule(scheduleId: string, staffScheduleRequest: StaffScheduleRequest, options?: RawAxiosRequestConfig) {
        return StaffManagementApiFp(this.configuration).updateStaffSchedule(scheduleId, staffScheduleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} templateId 
     * @param {StaffScheduleTemplateRequest} staffScheduleTemplateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateStaffScheduleTemplate(templateId: string, staffScheduleTemplateRequest: StaffScheduleTemplateRequest, options?: RawAxiosRequestConfig) {
        return StaffManagementApiFp(this.configuration).updateStaffScheduleTemplate(templateId, staffScheduleTemplateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

export const MarkStatusStatusEnum = {
    Available: 'AVAILABLE',
    Off: 'OFF',
    Cancelled: 'CANCELLED',
    Changed: 'CHANGED'
} as const;
export type MarkStatusStatusEnum = typeof MarkStatusStatusEnum[keyof typeof MarkStatusStatusEnum];


/**
 * UserManagementApi - axios parameter creator
 */
export const UserManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filter12: async (searchFilter: SearchFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchFilter' is not null or undefined
            assertParamExists('filter12', 'searchFilter', searchFilter)
            const localVarPath = `/api/admin/users/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockUserAccount: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('lockUserAccount', 'userId', userId)
            const localVarPath = `/api/admin/users/{userId}/lock`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockUserAccount: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('unlockUserAccount', 'userId', userId)
            const localVarPath = `/api/admin/users/{userId}/unlock`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserManagementApi - functional programming interface
 */
export const UserManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filter12(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePageUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filter12(searchFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserManagementApi.filter12']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lockUserAccount(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lockUserAccount(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserManagementApi.lockUserAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlockUserAccount(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlockUserAccount(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserManagementApi.unlockUserAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserManagementApi - factory interface
 */
export const UserManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserManagementApiFp(configuration)
    return {
        /**
         * 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filter12(searchFilter: SearchFilter, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePageUserResponse> {
            return localVarFp.filter12(searchFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockUserAccount(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.lockUserAccount(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockUserAccount(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVoid> {
            return localVarFp.unlockUserAccount(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserManagementApi - object-oriented interface
 */
export class UserManagementApi extends BaseAPI {
    /**
     * 
     * @param {SearchFilter} searchFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public filter12(searchFilter: SearchFilter, options?: RawAxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).filter12(searchFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public lockUserAccount(userId: string, options?: RawAxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).lockUserAccount(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public unlockUserAccount(userId: string, options?: RawAxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).unlockUserAccount(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VitalSignControllerApi - axios parameter creator
 */
export const VitalSignControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {VitalSignRequest} vitalSignRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVital: async (id: string, vitalSignRequest: VitalSignRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createVital', 'id', id)
            // verify required parameter 'vitalSignRequest' is not null or undefined
            assertParamExists('createVital', 'vitalSignRequest', vitalSignRequest)
            const localVarPath = `/api/examinations/{id}/vitals`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vitalSignRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filterVitals: async (id: string, searchFilter: SearchFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('filterVitals', 'id', id)
            // verify required parameter 'searchFilter' is not null or undefined
            assertParamExists('filterVitals', 'searchFilter', searchFilter)
            const localVarPath = `/api/examinations/{id}/vitals/filter`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVitals: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getVitals', 'id', id)
            const localVarPath = `/api/examinations/{id}/vitals`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} vitalId 
         * @param {VitalSignRequest} vitalSignRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveOrUpdateVitals: async (id: string, vitalId: string, vitalSignRequest: VitalSignRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('saveOrUpdateVitals', 'id', id)
            // verify required parameter 'vitalId' is not null or undefined
            assertParamExists('saveOrUpdateVitals', 'vitalId', vitalId)
            // verify required parameter 'vitalSignRequest' is not null or undefined
            assertParamExists('saveOrUpdateVitals', 'vitalSignRequest', vitalSignRequest)
            const localVarPath = `/api/examinations/{id}/vitals/{vitalId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"vitalId"}}`, encodeURIComponent(String(vitalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vitalSignRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VitalSignControllerApi - functional programming interface
 */
export const VitalSignControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VitalSignControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {VitalSignRequest} vitalSignRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVital(id: string, vitalSignRequest: VitalSignRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVitalSignResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVital(id, vitalSignRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VitalSignControllerApi.createVital']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filterVitals(id: string, searchFilter: SearchFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponsePageVitalSignResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filterVitals(id, searchFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VitalSignControllerApi.filterVitals']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVitals(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVitalSignResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVitals(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VitalSignControllerApi.getVitals']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} vitalId 
         * @param {VitalSignRequest} vitalSignRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveOrUpdateVitals(id: string, vitalId: string, vitalSignRequest: VitalSignRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomApiResponseVitalSignResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveOrUpdateVitals(id, vitalId, vitalSignRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VitalSignControllerApi.saveOrUpdateVitals']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VitalSignControllerApi - factory interface
 */
export const VitalSignControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VitalSignControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {VitalSignRequest} vitalSignRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVital(id: string, vitalSignRequest: VitalSignRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVitalSignResponse> {
            return localVarFp.createVital(id, vitalSignRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {SearchFilter} searchFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filterVitals(id: string, searchFilter: SearchFilter, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponsePageVitalSignResponse> {
            return localVarFp.filterVitals(id, searchFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVitals(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVitalSignResponse> {
            return localVarFp.getVitals(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} vitalId 
         * @param {VitalSignRequest} vitalSignRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveOrUpdateVitals(id: string, vitalId: string, vitalSignRequest: VitalSignRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomApiResponseVitalSignResponse> {
            return localVarFp.saveOrUpdateVitals(id, vitalId, vitalSignRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VitalSignControllerApi - object-oriented interface
 */
export class VitalSignControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {VitalSignRequest} vitalSignRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createVital(id: string, vitalSignRequest: VitalSignRequest, options?: RawAxiosRequestConfig) {
        return VitalSignControllerApiFp(this.configuration).createVital(id, vitalSignRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {SearchFilter} searchFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public filterVitals(id: string, searchFilter: SearchFilter, options?: RawAxiosRequestConfig) {
        return VitalSignControllerApiFp(this.configuration).filterVitals(id, searchFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getVitals(id: string, options?: RawAxiosRequestConfig) {
        return VitalSignControllerApiFp(this.configuration).getVitals(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} vitalId 
     * @param {VitalSignRequest} vitalSignRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public saveOrUpdateVitals(id: string, vitalId: string, vitalSignRequest: VitalSignRequest, options?: RawAxiosRequestConfig) {
        return VitalSignControllerApiFp(this.configuration).saveOrUpdateVitals(id, vitalId, vitalSignRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



